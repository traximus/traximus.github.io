<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Traximus‘pages]]></title>
  <link href="http://traximus.github.io/atom.xml" rel="self"/>
  <link href="http://traximus.github.io/"/>
  <updated>2014-08-05T10:08:26+08:00</updated>
  <id>http://traximus.github.io/</id>
  <author>
    <name><![CDATA[traximus]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ARC内存管理拾遗]]></title>
    <link href="http://traximus.github.io/blog/2014/08/04/arcnei-cun-guan-li-shi-yi/"/>
    <updated>2014-08-04T14:52:09+08:00</updated>
    <id>http://traximus.github.io/blog/2014/08/04/arcnei-cun-guan-li-shi-yi</id>
    <content type="html"><![CDATA[<blockquote><p>这是我之前做的一些笔记，今天有空就又看了一下官方<code>ARC</code>的内存管理部分，算是对这部分进行简单的记录；<!--more--></p></blockquote>

<h3>heap &amp;&amp; stack</h3>

<table>
<thead>
<tr>
<th>  类别    </th>
<th align="center">     内存管理   </th>
<th align="center">     空间大小   </th>
<th align="center">           碎片         </th>
<th align="center">   分配方式     </th>
<th align="center">      效率   </th>
</tr>
</thead>
<tbody>
<tr>
<td>  heap     </td>
<td align="center">   programmer  </td>
<td align="center">        大       </td>
<td align="center">   new和delete产生内存碎片 </td>
<td align="center">       动态分配      </td>
<td align="center">  低</td>
</tr>
<tr>
<td>  stack    </td>
<td align="center">    编译器      </td>
<td align="center">        小       </td>
<td align="center">   FIFO，一一对应，无碎片   </td>
<td align="center">       编译器静态分配 </td>
<td align="center">  高</td>
</tr>
</tbody>
</table>


<hr />

<h3>MRR (manual retain-release)</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i">官方文档</a></p>

<h4>1）NSObject部分</h4>

<ul>
<li>通过<code>malloc</code>， <code>new</code>, <code>copy</code>获取的对象， <code>retainCount</code>+1</li>
<li>谁拥有，谁管理 （<code>ownership</code>）</li>
<li>主视图对子视图是强引用<code>strong</code>， 所以子视图只能对主视图弱引用weak，避免retain循环</li>
<li>应该在恰当的时机，remove <code>notification</code>，设置<code>delegate</code>为nil，即使在ARC下</li>
<li>集合类<code>NSArray</code>， <code>NSDictionary</code>， <code>NSSet</code>等，对包含的child object会进行管理，无需单独的内存管理；</li>
</ul>


<h4>2）CoreFoundation部分</h4>

<ul>
<li><code>create</code>, <code>copy</code>会形成own关系，不需要时应该<code>CFRelease((CFTypeRef)obj)</code></li>
<li><code>get</code>方式得到的object不形成own关系，不需要单独管理</li>
<li>一个object作为参数，传递到函数中后，receiver不与他形成own关系，也就是，可能在任何时间被<code>deallocate</code>掉，因此，需要<code>CFRetain(obj)</code></li>
<li><code>CFIndex count = CFGetRetainCount(obj)</code></li>
<li><code>myCFObj1 = myCFObj2</code> &mdash;>引用拷贝，不会生成2个对象，可以使用<code>CFStringCreateCopy</code>或者类似的方式，生成一个新对象</li>
<li>CF对象，copy的时候，需要自己实现<code>deep copy</code></li>
</ul>


<hr />

<h3>ARC (Automatic Reference Counting)</h3>

<p><a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226">官方文档</a></p>

<h4>1) 基本要点</h4>

<ul>
<li>可以根据需要，实现<code>dealloc</code>方法，来实现对<code>resource</code>的管理（比如，设置<code>delegate</code>为nil）</li>
<li><code>CoreFoundation</code>对象，仍然需要<code>CFRelease</code>，<code>CFRetain</code></li>
<li><code>assigned</code>的变量，在<code>ARC</code>下是<code>strong</code></li>
<li>不能使用c struct的指针，而应该创建一个对应的objC对象来管理数据</li>
<li>不能使用<code>retain</code>， <code>release</code>, <code>retainCount</code>，<code>[super dealloc]</code>,<code>NSAutoreleasePool</code>（使用<code>@autoreleasepool</code>代替）</li>
<li><p>为了兼容<code>MRR</code>,<code>ARC</code>对method的命名有一个约束：你不应该该一个<code>property</code>命名的时候，以<code>new</code>开头</p>

<p> &#8220;`
 // Won&rsquo;t work:
 @property NSString *newTitle;</p>

<p> // Works:
 @property (getter=theNewTitle) NSString *newTitle;</p>

<p> &#8220;`</p></li>
</ul>


<h4>2）变量修饰符</h4>

<ul>
<li><code>__strong</code>: is the default. An object remains “alive” as long as there is a strong pointer to it.</li>
<li><p><code>__weak</code>: A weak reference is set to nil when there are no strong references to the object.</p>

<p> <strong><code>outlets</code>最好申明为<code>weak</code></strong></p></li>
<li><p><code>__unsafe_unretained</code>: a reference that does not keep the referenced object alive and is not set to nil when there are no strong references to the object &ndash; 简单来说，就是不安全</p></li>
<li><code>__autoreleasing</code>: is used to denote arguments that are passed by reference (id *) and are autoreleased on return</li>
</ul>


<h4>3） MRR和ARC的转换</h4>

<ul>
<li><code>__bridge</code>: 直接转换CF对象和objC对象，不修改ownership</li>
<li><code>__bridge_retained</code> &amp;&amp; <code>CFBridgingRetain</code>: 将objC对象转换为CF对象，并同时修改<code>ownership</code>，之后，需要自己对该对象进行CFRelease()管理</li>
<li><p><code>__beidge_transfer</code> &amp;&amp; <code>CFBridgingRelease</code>: 将CF对象转换为objC对象，并修改<code>ownership</code>，之后的管理交给<code>ARC</code></p>

<p><strong>id和void *不能直接转换</strong></p></li>
</ul>


<hr />

<h5>基本上就是这么多吧，还有一些知识点没有罗列，只是记录了我自己容易忽略的部分。</h5>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[StaticCell &amp;&amp; PrototypeCell]]></title>
    <link href="http://traximus.github.io/blog/2014/07/17/staticcell-and-and-prototypecell/"/>
    <updated>2014-07-17T15:30:05+08:00</updated>
    <id>http://traximus.github.io/blog/2014/07/17/staticcell-and-and-prototypecell</id>
    <content type="html"><![CDATA[<blockquote><h4>这仍然是一篇关于   <code>storyboard</code>的笔记； 在我的项目中<code>TableView</code>使用的还是比较频繁，之前我对于自定义<code>cell</code>，一般都是新建一个<code>xib</code>，或者新建一个<code>customCell</code>类来解决；<!--more-->最近才发现，<code>storyboard</code>里面，可以直接自定义<code>cell</code>，很方便。同时提供两种类型cell， <code>static</code>， <code>prototype</code>; 下面是我关于这两种cell的简单笔记</h4></blockquote>

<hr />

<h2>1. Static Cell</h2>

<h5><code>static cell</code>, 顾名思义，就是静态cell，直接在storyboard中设置好，然后直接加载；无需再设置reuse identifier进行reuse; 当然，你可以在每一个static cell中，按照你的需要，自定义contentView；</h5>

<blockquote><p>PS1: 我这里尝试过给<code>static cell</code>添加<code>reuse identifier</code>,然后进行reuse，结果报错了；</p>

<p>PS2: 我尝试在<code>UIViewController</code>中使用<code>static cell</code>，结果发现，<code>static cell</code>只能在<code>UITableViewController</code>中使用；</p></blockquote>

<h2>2. Prototype Cell</h2>

<h4><code>prototype cell</code>，顾名思义，就是原型cell，这个cell作为一个原型，肯定可以进行reuse，当然也支持在storyboard中直接自定义contentView；</h4>

<blockquote><p>PS： prototype cell在UITableViewController和其他VC中都可以使用，没有static cell的限制；</p></blockquote>

<hr />

<h2>废话少说，我们来个基本的例子，来帮助理解；</h2>

<p><strong>首先，我们的例子app大概是这个样子；</strong></p>

<p><img src="http://traximus.github.io/images/2014-07-17-01.png" alt="summary" /></p>

<p><strong>主要结构很简单，一个基于导航栏的VC，上面3个按钮，分别push到VC1, VC2，VC3</strong></p>

<ul>
<li>VC1 &ndash; 基于UITableViewController的static cell</li>
<li>VC2 &ndash; 基于UITableViewController的prototype cell</li>
<li>VC3 &ndash; 基于UIViewController的prototype cell</li>
</ul>


<h4>1.VC1 &ndash; 基于UITableViewController的static cell</h4>

<ol>
<li><p>我们先添加一个UItableViewController，然后选择static cell</p>

<p><img src="http://traximus.github.io/images/2014-07-17-02.png" alt="summary" /></p></li>
<li><p>这里可以尝试尽量自定义设置属性； 比如，选中section部分，设置section header, footer， rows</p>

<p><img src="http://traximus.github.io/images/2014-07-17-03.png" alt="summary" /></p></li>
<li>选择一个cell，进行一些简单的自定义（注意，这里每一个cell是互不影响，你可以单独设置每一个cell的具体属性）
<img src="http://traximus.github.io/images/2014-07-17-04.png" alt="summary" /></li>
</ol>


<p>好了，VC1基本上就算完成了，你可以直接运行加载，你会发现，和我们预期的一样；</p>

<blockquote><p>PS1：如果我想让这个static cell上面的自定义按钮响应事件，或者支持编辑模式，怎么处理？ 其实这个和以前的处理方式一样：直接在对应的VC.m文件里，写上支持编辑模式的相关方法即可。 至于响应点击时间，我们直接通过IBOutlet关联事件方法就可以了。</p></blockquote>

<p>比如，我这里，对第一行cell的button关联了一个方法</p>

<p> <img src="http://traximus.github.io/images/2014-07-17-05.png" alt="summary" /></p>

<blockquote><p>PS2: static cell仍然是可以自定义headerView和footerView的</p></blockquote>

<hr />

<h4>2. VC2 &ndash; 基于UITableViewController的prototype cell</h4>

<ol>
<li><p>我们先添加一个UItableViewController,然后选择prototype cell</p>

<p><img src="http://traximus.github.io/images/2014-07-17-06.png" alt="summary" /></p></li>
<li><p>你会发现，你tableView上面cell，显示为prototype cells; 这里cell的数量，可以根据你的实际需要，进行添加或者减少；当然，每一行cell仍然可以完全自定义contentView； （我这里自定义了2个不同的cell，同时，<strong>需要分别设置不同的<code>reuse identifier</code></strong>）</p>

<p> <img src="http://traximus.github.io/images/2014-07-17-07.png" alt="summary" />    <img src="http://traximus.github.io/images/2014-07-17-08.png" alt="summary" /></p></li>
<li><p>然后，在对应的.m文件中，直接根据cell的reuse identifier即可；</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
</span><span class='line'>{
</span><span class='line'>    NSString *cellIdentifier;
</span><span class='line'>    if (indexPath.row!=[datasource count]-1) {
</span><span class='line'>        cellIdentifier = @"prototypeCell_TableViewController";
</span><span class='line'>    }
</span><span class='line'>    else{
</span><span class='line'>        cellIdentifier = @"cell2";
</span><span class='line'>    }
</span><span class='line'>    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier forIndexPath:indexPath];
</span><span class='line'>    
</span><span class='line'>    // Configure the cell
</span><span class='line'>    CellDataModel *cellData = [datasource objectAtIndex:indexPath.row];
</span><span class='line'>    
</span><span class='line'>    if (indexPath.row!=[datasource count]) {
</span><span class='line'>        UILabel *titleLabel = (UILabel *)[cell viewWithTag:Label_Tag];
</span><span class='line'>        UIButton *buttonT = (UIButton *)[cell viewWithTag:Button_Tag];
</span><span class='line'>        UISegmentedControl *segC = (UISegmentedControl *)[cell viewWithTag:SegmengControl_Tag];
</span><span class='line'>        titleLabel.text = cellData.title;
</span><span class='line'>        [buttonT setTitle:cellData.buttonTitle forState:UIControlStateNormal];
</span><span class='line'>        [segC setSelectedSegmentIndex:cellData.selectedIndex];
</span><span class='line'>    }
</span><span class='line'>    else{
</span><span class='line'>        cell.textLabel.text = cellData.title;
</span><span class='line'>        cell.detailTextLabel.text = cellData.buttonTitle;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return cell;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>然后运行，大概就是这个样子：</h4>

<p><img src="http://traximus.github.io/images/2014-07-17-09.png" alt="summary" /></p>

<h4>3. VC3  &ndash; 基于UIViewController的prototype cell</h4>

<ol>
<li>基本和VC2类似，只是UITableViewController换成了UIViewController；</li>
<li>注意，这里tableview和navgationBarItem的所处层级不一样，这个注意一下；</li>
</ol>


<hr />

<p>基本笔记就是这些了。以后有了再慢慢更新。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Storyboard相关笔记]]></title>
    <link href="http://traximus.github.io/blog/2014/05/27/storyboardxiang-guan-bi-ji/"/>
    <updated>2014-05-27T19:08:52+08:00</updated>
    <id>http://traximus.github.io/blog/2014/05/27/storyboardxiang-guan-bi-ji</id>
    <content type="html"><![CDATA[<blockquote><h4>Storyboard出来这个么长时间了，我自己使用的却不是很多，也不够熟练，这里只是简单的记录一下相关笔记，主要是搞清楚segue，scene,以及他们之间的跳转关系，部分资料也是参考别人的整理。<!--more--></h4></blockquote>

<h5>首先简单看一下</h5>

<p><img src="http://traximus.github.io/images/2014-05-27-01.png" alt="summary" /></p>

<p>一个<code>Storyboard</code>管理多个<code>VC</code>，这多个<code>VC</code>就看做是多个<code>scene</code>,视图之间的跳转关系定义都可以在<code>Storyboard</code>中完成。</p>

<hr />

<h2>segue类型介绍</h2>

<p>这里的简介转载自<a href="http://www.2cto.com/kf/201210/161737.html">http://www.2cto.com/kf/201210/161737.html</a></p>

<blockquote><p>在storyboard中，segue有几种不同的类型，且iPhone和iPad对应的segue也不尽相同；</p>

<p>在iPhone中，segue有push， modal，custom三种不同类型，这些segue定义了跳转时分别对应的方式；</p>

<p>在iPad中，segue有push， modal，replace, popover， custom五种方式；</p></blockquote>

<ul>
<li>modal 模态视图，弹出的模态视图，用户只能在该View上响应，不再使用，需要dismiss</li>
<li>push  配合导航栏NavigationController一起使用，从右侧划入的方式</li>
<li>popover 浮动窗视图，iPad专用；</li>
<li>replace  替换当前scene， iPad专用</li>
<li>custom  自定义跳转方式</li>
</ul>


<hr />

<h2>Storyboard的创建</h2>

<ol>
<li>可以直接使用项目默认的storyboard，也可以自己添加多个storyboard;</li>
<li><p>获取storyboard</p>

<p><code>+ (UIStoryboard *)storyboardWithName:(NSString *)name bundle:(NSBundle *)storyboardBundleOrNil</code></p></li>
<li><p>获取storyboard中的某个VC，然后对该VC进行相应的segue操作</p>

<p><code>- (id)instantiateInitialViewController;</code></p>

<p><code>- (id)instantiateViewControllerWithIdentifier:(NSString *)identifier;</code></p></li>
<li>一个VC在被触发跳转之间，会调用下面的方法，一般进行数据传递</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// In a storyboard-based application,  do a little preparation before navigation
</span><span class='line'>- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
</span><span class='line'>{
</span><span class='line'>  // used to transfer some data to new VC
</span><span class='line'>          // Get the new view controller using [segue destinationViewController].
</span><span class='line'>  // Pass the selected object to the new view controller.
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>对于一个VC，可以使用下面的方法，来指定执行哪一个segue(如果该VC指定了多个segue)，或者查询segue是否可用</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (void)performSegueWithIdentifier:(NSString *)identifier sender:(id)sender
</span><span class='line'>
</span><span class='line'>- (BOOL)shouldPerformSegueWithIdentifier:(NSString *)identifier sender:(id)sender 
</span><span class='line'>
</span><span class='line'>// Invoked immediately prior to initiating a segue. Return NO to prevent the segue from firing.
</span><span class='line'>// The default implementation returns YES. 
</span><span class='line'>// This method is not invoked when -performSegueWithIdentifier:sender: is used.
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>对于一个VC，可以指定segue类型为modal时的style</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>/*
</span><span class='line'>      Defines the transition style that will be used for this view controller when it is 
</span><span class='line'>      presented modally. Set this property on the view controller to be presented, not the presenter.
</span><span class='line'>      Defaults to UIModalTransitionStyleCoverVertical.
</span><span class='line'>*/
</span><span class='line'>
</span><span class='line'>@property(nonatomic,assign) UIModalTransitionStyle modalTransitionStyle NS_AVAILABLE_IOS(3_0);
</span><span class='line'>@property(nonatomic,assign) UIModalPresentationStyle modalPresentationStyle NS_AVAILABLE_IOS(3_2);
</span></code></pre></td></tr></table></div></figure>


<pre><code>**UIModalTransitionStyle &amp;&amp; UIModalPresentationStyle 的定义为：**
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>typedef NS_ENUM(NSInteger, UIModalTransitionStyle) {
</span><span class='line'>  UIModalTransitionStyleCoverVertical = 0,
</span><span class='line'>  UIModalTransitionStyleFlipHorizontal,
</span><span class='line'>  UIModalTransitionStyleCrossDissolve,
</span><span class='line'>  UIModalTransitionStylePartialCurl,
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>typedef NS_ENUM(NSInteger, UIModalPresentationStyle) {
</span><span class='line'>  UIModalPresentationFullScreen = 0,
</span><span class='line'>  UIModalPresentationPageSheet,
</span><span class='line'>  UIModalPresentationFormSheet,
</span><span class='line'>  UIModalPresentationCurrentContext,
</span><span class='line'>  UIModalPresentationCustom,
</span><span class='line'>  UIModalPresentationNone = -1,               
</span><span class='line'>};
</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>Storyboard的简单使用</h2>

<ol>
<li><p>一般情况下，一个storyboard至少管理者一个scene，对于VC之间的跳转segue可以直接从能触发的控件，
按住Control，然后连接到另一个你需要跳转的VC上，记住，你最好给segue设置一个identifier。</p></li>
<li><p>同时，你可以不指定segue，只给某一个VC指定一个Storyboard ID, 在使用的时候，直接调用下面的方法来获取VC</p>

<p> <code>- (id)instantiateViewControllerWithIdentifier:(NSString *)identifier;</code></p></li>
</ol>


<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebDAV助手1.2]]></title>
    <link href="http://traximus.github.io/blog/2014/03/25/webdavzhu-shou-1-dot-2/"/>
    <updated>2014-03-25T18:38:23+08:00</updated>
    <id>http://traximus.github.io/blog/2014/03/25/webdavzhu-shou-1-dot-2</id>
    <content type="html"><![CDATA[<blockquote><p>经过一段时间的折腾，WebDAV助手1.2终于在20号上线了, <a href="https://itunes.apple.com/cn/app/webdav-zhu-shou-jian-dan-fang/id659323471?mt=8">iTunes地址</a>。 这个版本是过渡版本，主要是是做了进一步的iOS7适配，以及部分文件访问逻辑进行了调整； 最主要的目的，就是为下一个版本更新做准备。<!--more--></p></blockquote>

<h4>部分截图</h4>

<p><img src="http://traximus.github.io/images/2014-03-25-01.png" alt="summary" /></p>

<p><img src="http://traximus.github.io/images/2014-03-25-02.png" alt="update" /></p>

<hr />

<h4>这个业余项目，主要是想用自己学到的技术，试试能不能做个像样的小东西出来。过程还是酸甜苦辣咸都有。</h4>

<h4>目前不满意的部分，主要是这几个部分，也相当于是改进计划吧</h4>

<ul>
<li>icon &ndash;  毕竟我不是美术专业人员，弄出这么个东西都是靠<code>Androidify</code>帮忙，项改进得另想他法</li>
<li>交互体验  &ndash;  目前的交互，是学习dropbox做的，感觉不是很适合这个app的多服务器切换模式；目前计划是下个版本，更新为<code>Yahoo天气</code>的结构</li>
<li>网络访问 &ndash; 目前使用的是系统默认的网络访问，而且管理网络的单例写的并不是很好，总感觉效率还有待提高；下一个版本可能替换为<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a></li>
<li>本地文件共享 &ndash; 目前尚未加入，考虑下一个版本添加进来</li>
<li>AirDrop文件分享 &ndash; 由于AirDrop仅仅支持iPhone5, iPad4, iPad mini, iPod touch 5，可能要放弃一部分用户了。</li>
</ul>


<hr />

<h4>说实话，这种专业性比较强的app，对于我这种后进者来说，除非做的很出彩，不然很难被广泛接受；唯一不足的，是我原本以为的重点功能还没有被人发掘使用（将iPod音乐库的音乐导出来，上传到设定的WebDAV服务器）+_+</h4>

<p>不过既然是作为业余爱好，我会长期坚持下去，总能把这个项目做得越来越好的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用instruments]]></title>
    <link href="http://traximus.github.io/blog/2014/02/11/ru-he-shi-yong-instruments/"/>
    <updated>2014-02-11T16:03:08+08:00</updated>
    <id>http://traximus.github.io/blog/2014/02/11/ru-he-shi-yong-instruments</id>
    <content type="html"><![CDATA[<blockquote><p>源地址：<a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode">http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode</a></p></blockquote>

<hr />

<h2>学习使用Xcode的instruments工具来定位问题，优化你的app</h2>

<p>在你的iOS开发生涯中，你或许已经已经做过1到2个app，而且也明白如何做的更好。在给你的app添加新功能和特性的同时，你也应该注意另外一件事：使用<code>instruments</code>帮助优化你的app.</p>

<p>这篇教程将会讲解如何使用<code>instruments</code>工具的重要功能来配合<code>Xcode</code>优化你的app，他可以帮你检查关于性能，内存泄漏以及其他问题。<!--more--></p>

<p><img src="http://traximus.github.io/images/2014-02-11-01.png" alt="instruments" /></p>

<p><strong>这篇文章中，你会接触到以下内容：</strong></p>

<ul>
<li>使用<code>Allocations</code> 以及 <code>Leaks</code>来检测并修复你代码中的内存管理问题</li>
<li>使用<code>Time Profiler</code>定位你代码中的<code>hot-spots</code>,并教你如何让你的代码更加有效率；</li>
</ul>


<blockquote><p>注意：这篇教程的前提是你已经熟悉<code>Objective_C</code>和iOS开发相关知识，如果你是初学者，你可以看看其他的<a href="http://www.raywenderlich.com/tutorials">教程</a>;另外，本使用了<code>Xcode5</code>以及<a href="http://www.raywenderlich.com/5138/beginning-storyboards-in-ios-5-part-1">storyboard</a>，你应该已经熟知相关内容。</p></blockquote>

<p>一切就绪，让我们一起沉侵于Instruments的奇妙世界！</p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>instruments的打开途径有2种： 
</span><span class='line'>
</span><span class='line'>1. Xcode菜单栏-&gt;Product-&gt;Profile                                  用来分析当前Xcode项目
</span><span class='line'>2. Dock栏，右键单击Xcode图标-&gt;Open Developer Tools-&gt;Instruments     可以用来检测指定app的信息</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>初步工作</h2>

<p>这篇教程为你提供了一个示例项目，我们将一步一步的按照教程，使用instruments对整个项目进行优化。<a href="http://cdn4.raywenderlich.com/downloads/InstrumentsTutorial.zip">你可以从这里下载</a></p>

<p>下载项目以后，编译运行（假设我们输入关键字dog，搜索，然后点击results,可以看到类似于下面的页面：）</p>

<p><img src="http://traximus.github.io/images/2014-02-11-02.png" alt="search results of 'dog'" /></p>

<p>大致浏览一下app，这个app的基本功能就是搜索flickr的照片，并进行展示。顶部有一个search bar，你输入关键字，进行搜索以后，会有一个results结果，点击结果，显示一个新的table，同时显示搜索到图片的预览。单击某一个图片预览，就会进入一个新页面，展示该图片；</p>

<p>目前为止，一切和预期的一样，看起来没什么问题。无论如何，接下来你讲看到如何使用instruments发现这个app中众多潜在的问题，并进行调试优化，你会发现整个过程比你想象的要容易一些。</p>

<hr />

<h2>开始分析</h2>

<p>许多开发者在规划app的时候，总是充满了丰富的奇思妙想 &ndash; 事实上也确实是非常有价值的目标。然后他们阅读了一些类似于“过早优化”的类容，并且想知道如何避免这些糟糕的情况。</p>

<p>从某种程度上来说，你可以在你的开发流程之外进行你的优化工作。现在的移动设备已经足够强大，但是作为开发者，你不能总是依赖于提升硬件和处理处速度来粉饰你app那超低的效率。</p>

<p><strong>分析，要找对合适的地方</strong></p>

<p>你可以花一个星期的时间微调某一个有趣的算法，但是如果这个算法只占总执行时间的0.5%，那么没有人会注意到其中的差别；但是另一方面，如果你花费大量精力去优化你程序所使用到的很耗时的循环，即使你只取得了10%的改善，效果会非常明显。</p>

<h4>Time Profiler</h4>

<p>跟踪记录每一个method的CPU时间消耗，或者每一个线程的栈情况，先睹为快：</p>

<p><img src="http://traximus.github.io/images/2014-02-11-03.png" alt="Time Profiler" /></p>

<p><img src="http://traximus.github.io/images/2014-02-11-04.png" alt="Time Profiler" /></p>

<p>这张图片显示了每一个线程的call stack，每一level或者frame,在被调用后，不同methods在程序中的调用路径，以及CPU当前执行到的位置 &ndash; 也就是frame 0。每一个method的时间消耗都可以从profiler进入该method的次数来判断。</p>

<p>取个例子：如果有100份会消耗1毫秒的样本，而某一个method中在stack中调用了10份样本的话，你就可以粗略的推断出这个method会消耗10毫秒，这虽然是个近似值，但是很管用！</p>

<p><strong>事不宜迟，现在开始使用instruments来进行分析</strong>
打开例子项目，在Xcode的菜单栏，<code>Product</code>&ndash;><code>Profile</code>，进入instruments界面。
选择<code>Time Profiler</code>&ndash;><code>Profiler</code>，然后会在模拟器中运行app（这里可能还需要你输入密码，输入即可）</p>

<p>现在，开始在模拟器中使用app，输入搜索关键字，在得到搜索结果以后，点击进入结果列表，直接滑动结果列表，或者点击查看一张image，你会发现，app反应非常的慢，真是太糟糕了！</p>

<p>幸运的是，我们可以修复这个问题。首要目标就是找对instruments中相对应的分析器（确保instruments的View同时选中了这3种模式）
<img src="http://traximus.github.io/images/2014-02-11-05.png" alt="instruments view option" /></p>

<p>下面是instruments Time Profiler的主要区域</p>

<p><img src="http://traximus.github.io/images/2014-02-11-06.jpeg" alt="instruments Time Profiler Main section" /></p>

<ol>
<li>开始 &amp; 结束</li>
<li>app运行计时器 &ndash; 时间表示app本次进行profile运行的时间， <code>Run 1 of 1</code>表示app运行的次数（如果你stop后再重新start，会显示 <code>Run 2 of 2</code>）</li>
<li>app运行消耗轨迹 &ndash; 在Time Profiler状态，能清晰的表示出app的时间消耗</li>
<li>扩展的详细面板 &ndash; 在Time Profiler状态，主要显示instruments记录的栈记录</li>
<li>详细面板 &ndash; 主要展示了methods的时间消耗情况，可以简单的分析哪一个method占用了更多的CPU时间；当你点击某一个具体的method时，扩展面板会显示相应的栈记录</li>
<li>option面板</li>
</ol>


<hr />

<h2>深入挖掘</h2>

<p>执行一次搜索，当获取到搜索结果以后，多尝试几次上下滑动；然后可以暂停Time Profiler，你会看到，刚才标记为3的区域，记录了很多CPU时间消耗.为了查明问题所在，你需要设置更多的Time Profiler选项。</p>

<p>左下区域，选择<code>Separate by Thread</code>, <code>Invert Call Tree</code>, <code>Hide System Libraries</code> ,  <code>Show Obj-C Only</code></p>

<p><img src="http://traximus.github.io/images/2014-02-11-10.png" alt="instruments Time Profiler option" /></p>

<ul>
<li>Separate by Thread   : 单独区分每一个线程，让你能查看每一个线程的CPU消耗情况</li>
<li>Invert Call Tree     : 让被调用的method处于frame0位置，可以直观的看到调用的最深层次的method</li>
<li>Hide Missing Symbols : 当找不到dSYM文件时，此选项能帮助你仅显示完整识别的method名，其余method隐藏</li>
<li>Hide System Libraries: 仅显示你来自于你app的method信息（系统对CPU消耗，你无能为力）</li>
<li>Show Obj-C Only      : 仅显示Objective-C method</li>
<li>Flatten Recursion    : 对于递归method，仅作为一个入口，而不是多个</li>
<li>Top Functions        : 开启此功能，会对method的CPU占用时间做和统计（比如：A调用了B,那么统计A的时间时就会算上B的时间）</li>
</ul>


<p>设置Time Profiler之前
<img src="http://traximus.github.io/images/2014-02-11-07.png" alt="before Time Profiler option" /></p>

<p>设置Time Profiler之后
<img src="http://traximus.github.io/images/2014-02-11-08.png" alt="after Time Profiler option" /></p>

<p>仔细查看设置后的详细信息区域，发现CPU时间消耗，大部分都在<code>-[PhotoCell setPhoto:]</code>方法中，因为在tableView进行滚动的时候，cell一直在更新，而cell显示的photo也一直需要update；为了搞清楚具体情况，双击<code>-[PhotoCell setPhoto:]</code>，会看到下面的代码(我这里得到的信息和原文有点出入，我以实际情况为准)</p>

<p><img src="http://traximus.github.io/images/2014-02-11-09.png" alt="PhotoCell setPhoto:" /></p>

<p><strong>如你所见，时间主要花在这两个部分：获取image data &amp;&amp; create image，这就是问题所在：</strong></p>

<ul>
<li><p>[NSData dataWithContentsOfURL: 在data被下载之前会一直block（不返回），而且由于运行在main thread里面，会block UI，每一次请求都会花费一定时间,所以滑动的时候，多次请求就会让整个滑动过程非常糟糕。</p>

<p>解决的办法是异步加载image数据；点击instruments的这个位置（会自动打开Xcode，定位到相应的文件和代码区域）</p>

<p><img src="http://traximus.github.io/images/2014-02-11-11.jpeg" alt="open Xcode:" />
然后代码作如下改动</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  -(void)setPhoto:(FlikrPhoto *)photo
</span><span class='line'>  {
</span><span class='line'>      _photo = photo;
</span><span class='line'>      self.textLabel.text = photo.title;
</span><span class='line'>      
</span><span class='line'>      // NSData *imageData = [NSData dataWithContentsOfURL: _photo.thumbnailUrl];
</span><span class='line'>      // self.imageView.image = [UIImage imageWithData: imageData];
</span><span class='line'>      
</span><span class='line'>      [[ImageCache sharedInstance] downloadImageAtURL: _photo.thumbnailUrl
</span><span class='line'>                                      completionHandler:^(UIImage *image){
</span><span class='line'>                                          self.imageView.image = image;
</span><span class='line'>                                          [self setNeesLayout];
</span><span class='line'>                                      }];
</span><span class='line'>  }
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p>  然后再执行<code>Product</code>&ndash;><code>Profile</code>&ndash;><code>Time Profiler</code>&ndash;><code>Profile</code>,搜索，然后在结果列表界面进行滑动，你会发现，上下滑动结果的时候，顺畅多了。<strong>接下来，我们能优化更多</strong>；</p>

<hr />

<blockquote><p>关于 memory leaks(内存泄露),主要有2种。第一种我们叫做真实的memory leak(一个object在不再使用后没有被deallocated，导致这部分内存不能被重新使用)； 另一种就有点意思了，我们叫做<code>unbounded memory growth(无限制的内存增长)</code>，这种情况下，会不停的allocate内存但是一致没有机会被deallocated;
memory leaks是非常严重的问题，因为他可能在某个时间导致耗尽你的系统内存，从而被iOS的系统watch dog关闭你的app；</p></blockquote>

<hr />

<h2>超级重要的Allocations</h2>

<p>接下来，我们会使用Allocations仪器，帮助我们分析每一个object的内存分配和管理，当然也可以查看到一个object的内存计数器。</p>

<p><code>Product</code>&ndash;><code>Profile</code>&ndash;><code>Allocations</code>&ndash;><code>Profile</code></p>

<p><img src="http://traximus.github.io/images/2014-02-11-12.png" alt="Allocations" /></p>

<p>app会自动运行，然后你会看到类似于下面的情况</p>

<p><img src="http://traximus.github.io/images/2014-02-11-13.png" alt="Allocations" /></p>

<p>这里你需要关注2大主要的跟踪记录：<code>Allocations</code>和<code>VM Tracker</code>；Allocations我们将会在接下来的时间详细讲解， VM Tracker也非常有用，只是稍微复杂一点。</p>

<p><strong>我们做下面的实验，来找出例子项目中的内存问题：</strong></p>

<p><em>进行10次不同关键字的搜索（进入结果列表但是不要进入具体图片界面），确保每次搜索都有一些结果；然后让app等待几秒钟</em>；</p>

<p>你应该已经注意到了，<code>Allocations</code>区域的图表记录一直在增长，也就是说，app在allocate新的内存；现在，我们需要尝试进行<strong><code>heap shot analysis</code></strong>：运行app的同时，点击左侧区域的<code>Mark Generation</code>按钮；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>heap信息快照，主要是为了多次执行同一个操作，观察内存是否无限制的增长（这里我们点击一个搜索结果，然后等待图片加载，
</span><span class='line'>加载完毕以后，再换另一个搜索结果，再点击进入等待图片加载，如此返回，对多个搜索结果进行测试）
</span><span class='line'>你会看到类似于下面的情况：</span></code></pre></td></tr></table></div></figure>


<p><img src="http://traximus.github.io/images/2014-02-11-14.png" alt="Mark Generation" /></p>

<p>通过上面的图，发现了一些问题：每次重新选择一个搜索结果，点击进入，图片加载以后再切换另一个搜索结果，内存总是在不停的增长；</p>

<p>我们都知道，iOS系统有一个内存警告方法，当系统内存吃紧的时候，会发送这个消息，app可以在这个方法里面释放不需要的内存；我们可以在iOS模拟器里面模拟这个内存警告（硬件->模拟内存警告）.你会发现，内存确实骤降了一些，但是远远达不到我们的要求，肯定还有其他什么地方存在着内存问题。</p>

<hr />

<h2>查找内存消耗大户 &ndash; 无约束的内存增长</h2>

<p>第一次<code>Mark Generation</code>产生的数据作为一个基准，后面每一次<code>Mark Generation</code>产生的数据，都是以前面的mark作为参考对象，所以，你可以通过查看<code>Growth</code>这一列来看看，新增长了多少内存，展开查看到底哪些内存是新增的。</p>

<h5>展开其中一次记录，你会看到有如此多的objects，怎么处理呢？</h5>

<p>最好的方式，是查看你app直接使用的class相关信息，这个例子中，类似于<code>HTTPHeaderDict</code>, <code>CGRegion</code>, <code>CGPath</code>, <code>CFNumber</code>之类的对象，可以暂时忽略掉。</p>

<p>我们关注一下ImageCache（或者UIImage）,因为你的app直接处理该类；找到ImageCache这个类，展开，可以在右边的详细面板看到具体信息</p>

<p><img src="http://traximus.github.io/images/2014-02-11-15.png" alt="Mark Generation detail" /></p>

<h5>具体分析</h5>

<p>右边的项目信息中，灰色部分是system library, 黑色部分是我们app的method,你可以双击黑色部分，进入到相应的代码段；我们来看这一段代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)downloadImageAtURL:(NSURL*)url completionHandler:(ImageCacheDownloadCompletionHandler)completion {
</span><span class='line'>    UIImage *cachedImage = [self imageForKey:[url absoluteString]];
</span><span class='line'>    if (cachedImage) {
</span><span class='line'>        completion(cachedImage);
</span><span class='line'>    } else {
</span><span class='line'>        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
</span><span class='line'>            NSData *data = [NSData dataWithContentsOfURL:url];
</span><span class='line'>            UIImage *image = [UIImage imageWithData:data];
</span><span class='line'>            [self setImage:image forKey:[url absoluteString]];
</span><span class='line'>            dispatch_async(dispatch_get_main_queue(), ^{
</span><span class='line'>                completion(image);
</span><span class='line'>            });
</span><span class='line'>        });
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在这个方法内部，有一个[setImage: forKey:]方法，这个方法是将一个image对象存储到cache字典里，以防止再次使用（这就是问题所在，所以新的image出现以后，内存会不断的增长），现在我们来看这个方法实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)setImage:(UIImage*)image forKey:(NSString*)key {
</span><span class='line'>    [_cache setObject:image forKey:key];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个方法就是以url为key，把image添加到cache字典里，但是我们注意到，image没有在任何地方release(问题出现在这里); cache只会添加新的image但是从来不会清除cache，多以会导致内存“无约束增长”（前面说到的第二种类型内存问题）;</p>

<p>我们可以这样修复他：为imageCache这个类，添加监听memoryWarning的方法，当收到内存警告时，就清除cache；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//添加通知监听
</span><span class='line'>- (id)init {
</span><span class='line'>    if ((self = [super init])) {
</span><span class='line'>        _cache = [NSMutableDictionary new];
</span><span class='line'>        [[NSNotificationCenter defaultCenter] addObserver:self 
</span><span class='line'>                                  selector:@selector(memoryWarning:)        
</span><span class='line'>                                  name:UIApplicationDidReceiveMemoryWarningNotification object:nil];
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//进行相应的处理
</span><span class='line'>- (void)memoryWarning:(NSNotification*)note {
</span><span class='line'>    [_cache removeAllObjects];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>处理完毕，为了确保已经修复这个问题，我们关闭instruments，再次重新进入<code>Allocations</code>，和之前差不多，先搜索多个不同的关键字，然后先<code>Mark Generation</code>&ndash;>选择一个结果->进入结果列表->等待图片加载完毕->【模拟内存警告】，再<code>Mark Generation</code>&ndash;>选择另一个结果并接入结果列表->等待图片加载->【模拟内存警告】；如此反复；如果内存没有像之前那样不停的增长，那么，我们搞定他了。</strong></p>

<p>这是我这实际测试的情况</p>

<p><img src="http://traximus.github.io/images/2014-02-11-16.png" alt="Mark Generation" /></p>

<hr />

<h2>查找对象的memory leaks &ndash; 真实的内存泄露</h2>

<p>现在，我们来查找一下app中的第一种类型内存问题（一个object不再使用以后，没有得到释放）</p>

<p>在Xcode菜单栏，<code>Product</code>&ndash;><code>Profile</code>&ndash;><code>Leaks</code>&ndash;><code>Profile</code>；</p>

<p><img src="http://traximus.github.io/images/2014-02-11-17.png" alt="Leaks" /></p>

<p><code>Leaks</code>仪器主要包含2种类型记录：<code>Allocations</code>和<code>Leaks</code>;其中的<code>Allocations</code>仪器和之前使用的一样，现在需要着重关注<code>Leaks</code></p>

<p><img src="http://traximus.github.io/images/2014-02-11-18.png" alt="Leaks window" /></p>

<p>上图中，你会看到，默认的<code>Automatic Snapshotting</code>已经被选中，也就是说，只要有内存泄露，就会立即反应出来（上图中的红色竖线标记位置）；默认的自动记录时间间隔是10秒，你也可以随时按下<code>Snapshot Now</code>按钮在记录当前数据.</p>

<p><img src="http://traximus.github.io/images/2014-02-11-19.png" alt="Snapshot" /></p>

<h5>找到内存泄露并搞定他</h5>

<p>运行app，执行搜索，进入搜索结果，点击进入某一张图片页面，然后执行<code>Rotate</code>操作，你会看到红色竖线标记的内存泄露。现在，我们打开扩展信息面板，你会看到类似于下面的信息：</p>

<p><img src="http://traximus.github.io/images/2014-02-11-20.png" alt="Leaks extend detail info" /></p>

<p>所有问题都指向<code>rotateTapped</code>这个方法，我们现在来仔细的研究一个这段代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)rotateTapped:(id)sender {
</span><span class='line'>    UIImage *currentImage = _imageView.image;
</span><span class='line'>    CGImageRef currentCGImage = currentImage.CGImage;
</span><span class='line'> 
</span><span class='line'>    CGSize originalSize = currentImage.size;
</span><span class='line'>    CGSize rotatedSize = CGSizeMake(originalSize.height, originalSize.width);
</span><span class='line'> 
</span><span class='line'>    CGContextRef context = CGBitmapContextCreate(NULL,
</span><span class='line'>                                                 rotatedSize.width,
</span><span class='line'>                                                 rotatedSize.height,
</span><span class='line'>                                                 CGImageGetBitsPerComponent(currentCGImage),
</span><span class='line'>                                                 CGImageGetBitsPerPixel(currentCGImage) * rotatedSize.width,
</span><span class='line'>                                                 CGImageGetColorSpace(currentCGImage),
</span><span class='line'>                                                 CGImageGetBitmapInfo(currentCGImage));
</span><span class='line'> 
</span><span class='line'>    CGContextTranslateCTM(context, rotatedSize.width, 0.0f);
</span><span class='line'>    CGContextRotateCTM(context, M_PI_2);
</span><span class='line'>    CGContextDrawImage(context, (CGRect){.origin=CGPointZero, .size=originalSize}, currentCGImage);
</span><span class='line'> 
</span><span class='line'>    CGImageRef newCGImage = CGBitmapContextCreateImage(context);
</span><span class='line'>    UIImage *newImage = [UIImage imageWithCGImage:newCGImage];
</span><span class='line'> 
</span><span class='line'>    self.imageView.image = newImage;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>很多人都认为<code>ARC</code>能够处理好内存相关问题，只要使用了<code>ARC</code>，其他就不用管了；但事实上，<code>ARC</code>仅仅能正确地管理<code>Objective-C</code>对象，而上述代码中的<code>CoreFoundation</code>对象，就必须手动管理了。</strong></p>

<blockquote><p>CoreFoundation对象的内存管理规则：create,copy是拥有该对象，不再使用时，需要CFRelease();其他方式不需要释放；另外，当把一个object传递到一个方法中的时候，receiver不拥有该参数对象，因此该object可能在任何时间被deallocate掉，这个时候，receiver可以使用CFRetain（）主动维护该object; 另外，CF对象的拷贝，推荐使用CFXXCreateCopy()方法，而不是mutable拷贝（其中的XX表示类型，比如CFStringCreateCopy）</p></blockquote>

<p>现在检查一下上面的代码段，你会发现，<code>context</code>和<code>newCGImage</code>没有进行相应的释放;因为，在上述方法结束前添加下面的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGImageRelease(newCGImage);
</span><span class='line'>CGContextRelease(context);</span></code></pre></td></tr></table></div></figure>


<p>OK，现在重新编译，运行app，在<code>Leaks</code>中检查，执行rotate操作，你会发现没有内存泄露了。我们搞定他了！</p>

<hr />

<h2>接下来你可以干点什么</h2>

<p>你应该尽量让instruments称为你开发流程的一部分，以确保你开发出牛逼而有用的app！</p>

<hr />

<h4>这篇文章主要是讲解如何使用instruments来诊断app中可能存在的问题，主要是优化CPU时间消耗，查找潜在的内存问题并修复他们。由于我自己对Instruments也不是很熟悉，所以这是我自己的学习笔记，并没有完全按照原文翻译。原文使用的Xcode4版本，我使用的Xcode5所以存在少量的出入。上面的过程已经经过我自己的实践，希望能帮助到其他同学。</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习CoreGraphics]]></title>
    <link href="http://traximus.github.io/blog/2014/01/22/xue-xi-coregraphics/"/>
    <updated>2014-01-22T20:03:43+08:00</updated>
    <id>http://traximus.github.io/blog/2014/01/22/xue-xi-coregraphics</id>
    <content type="html"><![CDATA[<blockquote><h4>前段时间看了一些CoreGraphics资料，对CoreGraphics有了一定程度的认识，了解了基本用法，能实现一些简单的绘制功能。同时还在源地址发现了另一个东西PaintCode,能帮助实现自定义控件，同时我个人感觉PaintCode生成的代码，可读性还不错，也可以作为学习CoreGraphics的一种方式。<!--more--></h4></blockquote>

<hr />

<h2>CoreGraphics</h2>

<h4>1. <a href="http://www.raywenderlich.com/32283/core-graphics-tutorial-lines-rectangles-and-gradients">Lines,Rectangles, and Gradients</a></h4>

<h4>2. <a href="http://www.raywenderlich.com/32925/core-graphics-tutorial-shadows-and-gloss">Shadows and Gloss</a></h4>

<h4>3. <a href="http://www.raywenderlich.com/33193/core-graphics-tutorial-arcs-and-paths">Arcs and Paths</a></h4>

<h4>4. <a href="http://www.raywenderlich.com/33330/core-graphics-tutorial-glossy-buttons">Glossy Buttons</a></h4>

<h4>5. <a href="http://www.raywenderlich.com/33496/core-graphics-tutorial-patterns">Patterns</a></h4>

<h4>6. <a href="http://www.raywenderlich.com/34003/core-graphics-tutorial-curves-and-layers">Curves and Layers</a></h4>

<h4>7. How to Create a PDF with Quartz2D in iOS 5</h4>

<ul>
<li><a href="http://www.raywenderlich.com/6581/how-to-create-a-pdf-with-quartz-2d-in-ios-5-tutorial-part-1">part1</a></li>
<li><a href="http://www.raywenderlich.com/6818/how-to-create-a-pdf-with-quartz-2d-in-ios-5-tutorial-part-2">part2</a></li>
</ul>


<h4>8. <a href="http://www.raywenderlich.com/18840/how-to-make-a-simple-drawing-app-with-uikit">How to Make a Simple Drawing App with UIKit</a></h4>

<hr />

<h2>PaintCod径</h2>

<h4>1. <a href="http://www.raywenderlich.com/36341/paintcode-tutorial-dynamic-buttons">绘制动态按钮</a></h4>

<h4>2. <a href="http://www.raywenderlich.com/35720/paintcode-tutorial-custom-progress-bar">绘制自定义的ProgressBar</a></h4>

<h4>3. <a href="http://www.raywenderlich.com/38918/paintcode-tutorial-bezier-paths">绘制贝塞尔曲线</a></h4>

<hr />

<p><strong>PS1: 这是CoreGraphics一些列相关资料，循序渐进的学习，效果会比较不错;其中小部分文章有中文，其余是英文，如果有时间，我可以用我蹩脚的英语翻译一下。</strong></p>

<p><strong>PS2: 我记得其中PaintCode一篇生成的code是有问题的，可能是PaintCode的版本不一样导致的？我在实践的时候，发现好像是一个rect不对（时间有点久，从老blog搬过来的，实在记不起了>_&lt;），实践的时候可能稍微注意一下。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS performance Tips&amp;Tricksks]]></title>
    <link href="http://traximus.github.io/blog/2014/01/21/ios-performance-tips-and-tricksks/"/>
    <updated>2014-01-21T11:09:33+08:00</updated>
    <id>http://traximus.github.io/blog/2014/01/21/ios-performance-tips-and-tricksks</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks">http://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks</a></p></blockquote>

<p>app拥有良好的性能非常重要，这是保证良好用户体验的基石。这篇文章是基于原文，我自己的备忘记录。<!--more--></p>

<hr />

<h2>1.ARC</h2>

<p>新项目现在一般都是基于ARC了，就算使用ARC，很多情况下，还是会有内存泄露的情况存在，所以使用instrument就很必要了。</p>

<p><strong>如何使用instrument：英文<a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode">http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode</a></strong></p>

<p><strong>如何使用instrument：中文<a href="http://traximus.github.io/blog/2014/02/11/ru-he-shi-yong-instruments/">http://traximus.github.io/blog/2014/02/11/ru-he-shi-yong-instruments/</a></strong></p>

<hr />

<h2>2.Reuse</h2>

<h4>1)reuseidentifier</h4>

<ul>
<li>UITableViewCell</li>
<li>UICollectionViewCell</li>
<li>UITableViewHeaderFooterViews</li>
</ul>


<h4>2)Resue &amp;&amp; Lazy load</h4>

<p>学习UITableView的方式，不要一次性创建所有的subView,你只在需要的时候创建subView,并把它添加到reuse Queue;这可以避免大量的消耗。想啊次使用的时候，你只需要reuse即可。</p>

<h4>3)reuse Expensive object</h4>

<p>类似与NSDateFormatter, NSCalendar，这些object的初始化，设置效率比较低，代价比较大。针对这种情况，应该考虑重用。</p>

<p><strong>应对的做法有2种：</strong></p>

<ul>
<li>添加为class的变量，进行reuse</li>
<li>创建一个static variable</li>
</ul>


<p>对于第二种情况，你应该写一个类似与singleton的方法，来获取这个object</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(NSDateFormatter *)fotmatter
</span><span class='line'>{
</span><span class='line'>  static NSDateFormatter *formatter;
</span><span class='line'>  static dispatch_once_t onceToken;
</span><span class='line'>  dispatch_once(&onceToken, ^{
</span><span class='line'>      _formatter = [[NSDateFormatter alloc] init];
</span><span class='line'>      _formatter.dateFormat = @"EEE MMM dd HH:mm:ss Z yyyy";//twitter date format
</span><span class='line'>  });
</span><span class='line'>  
</span><span class='line'>  return formatter;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>3.set <code>opaque</code> to YES</h2>

<p>default</p>

<hr />

<h2>4.Avoid fat XIBs</h2>

<p>因为在XIB初始化的时候，会直接加载所有内容到内存中，增加大量的开销。因此，尽量把XIB拆分开，只在需要的时候在初始化并进行加载，这样就可以避免一次性加载国语复杂的xib所导致的内存和cpu过量消耗；</p>

<p>当然，现在很多项目使用stroyboard在一定程度上已经缓解了这个问题。</p>

<hr />

<h2>5.DO NOT block Main Thread</h2>

<ul>
<li>GCD</li>
<li>[NSURLConnection sendAsynchronousRequest: completionHandler:]</li>
</ul>


<hr />

<h2>6.<code>Size image</code> to imageVew&rsquo;s size</h2>

<p>事实上，将一个image放入到imageview中，并进行sizeToFit是有很大开销的,而且这部分开销可以避免；
当我们获取到image后，最好先进行resize,然后再放入到合适的imageView中；</p>

<hr />

<h2>7. Choose right data format and structure</h2>

<h4>1)choose <code>correct collection</code></h4>

<ul>
<li>NSArray：<strong>ordered</strong> list of values, <strong>Quick lookup</strong> by <strong>index</strong>, <strong>Slow lookup</strong> by <strong>value</strong>；<strong>Slow</strong> to insert&amp;delete</li>
<li>NSDictionary：key-value pairs, <strong>Quick lookup</strong> by <strong>key</strong></li>
<li>NSSet：unordered list of values, <strong>Quick lookup</strong>by <strong>value</strong>, <strong>Quick</strong> insert&amp;delete</li>
</ul>


<h4>2)choose <code>right data format</code></h4>

<ul>
<li>JSON &ndash; faster to parse, smaller than XML</li>
<li>XML &ndash; soap advantage</li>
</ul>


<h4>3)choose <code>corrent data storage option</code></h4>

<ul>
<li>NSUserDefaults    &ndash;   small data</li>
<li>XML,JSON,Plist    &ndash;   expensive operation to store and parse</li>
<li>NSCoding (archive)&ndash;   expensive as above</li>
<li>sqlite            &ndash;   easy to use</li>
<li>Core Data         &ndash;   like above</li>
</ul>


<hr />

<h2>8.enable GZIP compression</h2>

<hr />

<h2>9.cache</h2>

<p>对于不会变化，并且经常使用到的object进行cache; 对于http cache, 基本的第三方库都已经实现了cache; 对于一般的object，可以使用NSCache:<a href="http://nshipster.com/nscache/">http://nshipster.com/nscache/</a></p>

<hr />

<h2>10. Drawing performance</h2>

<p>考虑不同的绘图机制的性能</p>

<ul>
<li>UIKit</li>
<li>Core Animation</li>
<li>Core Graphics(相对于其他而言，更加高效)</li>
</ul>


<p>//绘制 Shadow Path</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//CoreAnimation - 这种方式代价高昂
</span><span class='line'>UIView *view= [[UIView alloc] init];
</span><span class='line'>view.layer.shadowOffst = CGSizeMake(-1.0, 1.0);
</span><span class='line'>view.layer.shadowRadius = 5.0;
</span><span class='line'>view.layer.shadowOpacity = 0.6;</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//effective way
</span><span class='line'>view.layer.shadowPath = [[UIBezierPath bezierPathWithRect: view.bounds] CGPath];</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>11.处理Memory Warnings</h2>

<p>常见有3中方式接收到memory warning</p>

<ol>
<li>applicationDidReceiveMemoryWarning: appDelegate</li>
<li>didReceiveMemoryWarning：           UIViewController</li>
<li>UIApplicationDidReceiveMemoryWarningNotification：notificationCenter</li>
</ol>


<hr />

<h2>12.Avoid Re-Processing Data</h2>

<p>这主要是数据出库的逻辑需要规划好</p>

<hr />

<h2>13. background image</h2>

<ul>
<li>full size image &ndash; [UIImage imageNamed:@&ldquo;test.png&rdquo;];</li>
<li>pattern image &ndash; [UIColor colorWithPatternImage:[UIImage imageNamed:@&ldquo;test.png&rdquo;]];</li>
</ul>


<hr />

<h2>14.reduce your web footprint</h2>

<p>尽量减少javascript的使用</p>

<hr />

<h2>15.Optimize tableview</h2>

<ul>
<li>reuse cell</li>
<li>set subview opaque</li>
<li>avoid gradients, image scale, offscreen drawing</li>
<li>cache height if height is variable</li>
<li>use asynchronously method for cell&#8217; contents</li>
<li>use shadowPath to set shadow</li>
<li>reduce te number of subViews</li>
<li>do as little work possible in <code>cellForRowAtIndexPath:</code></li>
<li>use the appropriate data structure</li>
<li>use <code>rowHeight</code>, <code>sectionFooterHeight</code>,<code>sectionHeaderHeight</code> to set constant height instead of delegte(效率上能理解，设计上我自己暂时不是很理解这条)</li>
</ul>


<hr />

<h2>16.speed up Launch time</h2>

<p>注1：异步获取数据，延迟加载，避免臃肿的xib</p>

<p>注2：测试Launch time最有效的方式是，断开Xcode,单独运行你的app</p>

<hr />

<h2>17.image load</h2>

<ul>
<li>imageNamed:               &ndash;   首先从system cache里面查找该image，如果没有找到，再从文件加载image</li>
<li>imageWithContentsOfFile:  &ndash;   直接从文件加载image,不检查system cache</li>
</ul>


<p>注意：对于会多次使用到的image，选择imageNamed：更加合适，因为system cache会进行cache; 而对于单次使用的image，直接从文件加载的imageWithContentsOfFile:更加合适</p>

<hr />

<p>上面的知识点只是针对我个人做备忘，每一个人对此的理解不一样，因此建议看看原文。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中实现设备摇动检测]]></title>
    <link href="http://traximus.github.io/blog/2014/01/20/ioszhong-shi-xian-she-bei-yao-dong-jian-ce/"/>
    <updated>2014-01-20T15:01:09+08:00</updated>
    <id>http://traximus.github.io/blog/2014/01/20/ioszhong-shi-xian-she-bei-yao-dong-jian-ce</id>
    <content type="html"><![CDATA[<p>要检测iOS设备的摇动事件，网上有一些资料。我自己测试过的是下面这2种方式(其实算作一种，只是第二种方式可以在vc里面直接控制是否响应shake事件)<!--more--></p>

<ol>
<li>UIWndow</li>
<li>UIViewController(继承自UIResponder)</li>
</ol>


<hr />

<h3>1.UIWindow</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(void) motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event
</span><span class='line'>{
</span><span class='line'>  //开始
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>-(void) motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event
</span><span class='line'>{
</span><span class='line'>  if (motion == UIEventSubtypeMotionShake)
</span><span class='line'>  {
</span><span class='line'>      //触发结束
</span><span class='line'>      //
</span><span class='line'>      //这里可以促发系统震动，或者发送一个通知，进行相应的处理
</span><span class='line'>      //
</span><span class='line'>      //例子： 添加系统震动
</span><span class='line'>      //  AudioToolBox.framework
</span><span class='line'>      //  #import&lt;AudioToolbox/AudioToolbox.h&gt;
</span><span class='line'>      //  AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>-(void) motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event
</span><span class='line'>{
</span><span class='line'>  //取消
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>2.UIViewController</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#pragma mark - 
</span><span class='line'>#pragma mark - viewController methods
</span><span class='line'>
</span><span class='line'>-(BOOL) canBecomeFirstResponder
</span><span class='line'>{
</span><span class='line'>  //这里设定一个变量，来控制是否支持shake事件
</span><span class='line'>  return self.shakeDetectionOn;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>-(void) viewDidAppear:(BOOL)animated
</span><span class='line'>{
</span><span class='line'>  [super viewDidAppear:animated];
</span><span class='line'>  
</span><span class='line'>  if ([self canBecomeFirstResponder])
</span><span class='line'>  {
</span><span class='line'>      //下面这行代码，也可以写到viewDidLoad或者applicationDidFinishLaunch中
</span><span class='line'>      [[UIApplication sharedApplication] setApplicationSupportShakeToEdit:YES];
</span><span class='line'>      
</span><span class='line'>      [self becomFirstResponder];
</span><span class='line'>  }
</span><span class='line'>  else
</span><span class='line'>  {
</span><span class='line'>      NSLog(@"NOT supported");
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>#pragma mark -
</span><span class='line'>#pragma mark - UIResponder support motion
</span><span class='line'>
</span><span class='line'>-(void) motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event
</span><span class='line'>{
</span><span class='line'>  NSLog(@"======== shake begins ==========");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>-(void) motionCancelled:(UIEventSybtype)motion withEvent:(UIEvent *)event
</span><span class='line'>{
</span><span class='line'>  NSLog(@"======== shake cancelled ==========");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>-(void) motionEnd：（UIEventSubtype)motion withEvent:(UIEvent *)event
</span><span class='line'>{
</span><span class='line'>  if (motion == UIEventSubtypeMotionShake)
</span><span class='line'>  {
</span><span class='line'>      NSLog(@"======== shake ended ========");
</span><span class='line'>      //这里可以添加震动反馈，或者发送notification
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>======</p>

<h4>说实话，在实际应用中，很少有合适的场景会用到这个事件；</h4>

<p>而且上面的方式检测shake事件，我自己测试的时候，发现响应有一点延迟，肯定可以再改进；
找机会再慢慢研究一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP交互用到的MIME-Type对照]]></title>
    <link href="http://traximus.github.io/blog/2014/01/20/httpjiao-hu-yong-dao-de-mime-typedui-zhao/"/>
    <updated>2014-01-20T14:28:06+08:00</updated>
    <id>http://traximus.github.io/blog/2014/01/20/httpjiao-hu-yong-dao-de-mime-typedui-zhao</id>
    <content type="html"><![CDATA[<p>这是我自己的app中，需要解析xml文档，然后针对不同类型的文件，进行相应的操作。所以必须知道文件对应的mime-type（http返回的xml文档中有相应的描述）；<!--more--></p>

<hr />

<p><strong>下面是我自己根据wiki和测试后得到的数据，作为备忘：</strong></p>

<p><strong>音频 &ndash; Audio</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.mp3     audio/mpeg
</span><span class='line'>.aac      audio/x-aac
</span><span class='line'>.m4a      audio/mp4a-latm
</span><span class='line'>.aiff     audio/x-aiff
</span><span class='line'>.wav      audio/x-wav</span></code></pre></td></tr></table></div></figure>


<p><strong>视频 &ndash; Video</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.mov     video/quicktime
</span><span class='line'>.mp4      video/mp4
</span><span class='line'>.3gp      video/3gpp
</span><span class='line'>.m4v      video/x-m4v</span></code></pre></td></tr></table></div></figure>


<p><strong>图片 &ndash; Image</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.tiff        image/tiff
</span><span class='line'>.tif      image/tiff
</span><span class='line'>.jpg      image/jpeg
</span><span class='line'>.jpeg     image/jpeg
</span><span class='line'>.gif      image/gif
</span><span class='line'>.png      image/png
</span><span class='line'>.bmp      image/bmp
</span><span class='line'>.bmpf     image/bmp
</span><span class='line'>.ico      image/x-icon
</span><span class='line'>/xbm      image/x-bitmap</span></code></pre></td></tr></table></div></figure>


<p><strong>其他 &ndash; Other</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.pdf     application/pdf
</span><span class='line'>.txt      text/plain
</span><span class='line'>.zip      application/zip
</span><span class='line'>.tar      application/tar
</span><span class='line'>.rar      application/rar</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MAC下配置WebDAV服务器]]></title>
    <link href="http://traximus.github.io/blog/2014/01/15/macxia-pei-zhi-webdavfu-wu-qi/"/>
    <updated>2014-01-15T12:16:56+08:00</updated>
    <id>http://traximus.github.io/blog/2014/01/15/macxia-pei-zhi-webdavfu-wu-qi</id>
    <content type="html"><![CDATA[<hr />

<p><strong>PS1：这是之前我做NAS项目时的WebDAV部分资料，既然弄了这个新的blog，就搬过来了。</strong><!--more--></p>

<p><strong>PS2: 当时没有相关服务器，也找不到人来做，网上针对MAC系统搭建WebDAV服务器的资料也很少。源地址<a href="http://gigaom2.wordpress.com/2010/10/01/how-to-enable-webdav-on-your-mac-for-iwork-on-ipad/">http://gigaom2.wordpress.com/2010/10/01/how-to-enable-webdav-on-your-mac-for-iwork-on-ipad/</a> 原文针对iPad,我经过一定修改，在自己的lion上搭建成功。</strong></p>

<p><strong>PS3: 由于OS X 10.8以后好像没有“web共享“入口了(我自己是10.9没有该入口)所以先需要在终端中开启。</strong></p>

<hr />

<h1>什么是WebDAV?</h1>

<p>参见：<a href="http://baike.baidu.com/view/974023.htm">http://baike.baidu.com/view/974023.htm</a></p>

<blockquote><p>webDAV也就是“基于网络的分布式创作和版本控制协议”，他是HTTP协议的扩展. webDAV被用于对web服务器进行读写访问，而且每一台mac都自带了一个web server;</p>

<p>当你在系统设置中，打开“web共享”时，就已经运行了一个Apache web server; 虽然webDAV内置于mac系统中，但是在OS X中却没有默认开启；你需要使用管理员权限来开启webDAV配置。</p></blockquote>

<hr />

<h1>10.7.5以后没有“web共享”入口的解决办法</h1>

<h4>1.开启apache</h4>

<p>打开safari，输入<code>http://localhost</code>测试，如果显示 it works! 说明apache已经开启；否则，在终端中输入： <strong>sudo apachectl restart</strong></p>

<h4>2.这时用户根目录<code>http://localhost/~username</code>还不能访问，为了让<code>~/Sites</code>下面的内容可以访问，继续以下的几个步骤</h4>

<ol>
<li><p>查看username.conf文件是否存在</p>

<p><code>
ls /etc/apache2/users/
</code></p></li>
<li><p>若你的用户名.conf文件不存在，则需要手动建立一个</p>

<p><code>
cd /etc/apache2/users/
</code></p>

<p><code>
sodo vi username.conf
</code>
<strong>注：username是你的mac用户名</strong></p></li>
<li>粘贴以下内容到username.conf,注意把username替换为你自己的用户名</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   　 &lt;Directory "/Users/username/Sites/"&gt;
</span><span class='line'>
</span><span class='line'>　　　　Options Indexes MultiViews
</span><span class='line'>
</span><span class='line'>　　　　AllowOverride All
</span><span class='line'>
</span><span class='line'>　　　　Order allow,deny
</span><span class='line'>
</span><span class='line'>　　　　Allow from all　　
</span><span class='line'>
</span><span class='line'>　　　　&lt;/Directory&gt;</span></code></pre></td></tr></table></div></figure>


<p> 保存，退出，重启apache: sudo apachectl restart</p>

<p> <strong>接下来，现在就可以开始正式配置WebDAV服务器了</strong></p>

<p>============</p>

<h1>开始搭建WebDAV服务器</h1>

<h3>1.关闭web server(或者直接关闭apache server)</h3>

<p><img src="http://traximus.github.io/images/2014-01-16-01.jpeg" alt="turn off icon" /></p>

<h3>2.修改Apache Web Server配置文件</h3>

<p>打开launchpad,打开终端<strong>terminal</strong>
注意，需要权限的时候，输入你的管理员密码，或者提前修改httpd.conf文件的读写权限；</p>

<ul>
<li>转到etc文件夹：<code>cd /etc/apache2</code></li>
<li>编辑httpd.conf: <code>sudo vi httpd.conf</code></li>
<li>寻找到这一行<code>“Include/private/etc/apache2/extra/httpd-dav.conf”</code> 取消注释，也就是去掉这一行前面的#</li>
<li>wq保存，退出</li>
</ul>


<h3>3.修改WebDAV模块的配置文件</h3>

<p>到现在位置，WebDAV模块已经被打开了，这样下次apache Web Server启动的时候，就会自己寻找启动WebDAV模块的指令。</p>

<ul>
<li>打开终端，转到extra文件夹：<code>cd etc/apache2/extra</code></li>
<li>编辑httpd-dav.conf文件： <code>sudo vi http-dav.conf</code></li>
<li>使用下面的配置，取代已经存在的alias项和文件夹配置</li>
</ul>


<p><img src="http://traximus.github.io/images/2014-01-16-02.jpeg" alt="httpd-dav image" /></p>

<h3>4.创建WebDAV用户</h3>

<p>在第三步中，我们制定了一个密码文件<strong> /usr/webdav.passwd </strong> 他就是用于<strong>WebDAV</strong>模块验证用户的登陆验证；同时，我们制定了一个用户<strong>myMacMini</strong>；</p>

<p>所以，我们需要创建一个用户 <strong>myMacMini</strong></p>

<ul>
<li>打开终端，转到extra文件夹：  <code>cd /etx/apache2/extra</code></li>
<li>创建新的WebDAV用户名 <strong>myMacMini</strong> :  <code>sudo htpasswd -c /usr/webdav.passwd myMacMini</code></li>
</ul>


<h3>5.创建对应的WebDAV文件夹，并设定相应的权限</h3>

<p>在第三步的配置中，我们也设定了WebDAV文件夹的位置 <strong>、Library/WebServer/WebDAV</strong>；</p>

<p>所以，我们需要创建相应的文件夹路径：</p>

<ul>
<li>打开终端，转到extra文件夹： <code>cd /etc/apache2/extra</code></li>
<li>创建WebDAV文件夹:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo mkdir -p /Library/WebServer/WebDAV
</span><span class='line'>sudo mkdir -p /usr/var</span></code></pre></td></tr></table></div></figure>


<ul>
<li>设置适当的权限(也可以根据自己的需要，到相应的目录去设定权限)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo chown -R www:www /Library/WebServer/WebDAV
</span><span class='line'>sudo chown -R www:www /usr/var
</span><span class='line'>sudo chgrp www /usr/webdav.passwd</span></code></pre></td></tr></table></div></figure>


<h4>设置完成，重启apache server: <code>sudo apachectl restart</code></h4>

<hr />

<h4>OK,现在你可以尝试用一个WebDAV客户端，去连接你的WebDAV服务器，看看是不是能够正常查看和分享文件了？</h4>

<ul>
<li>服务器地址： <code>http://你的ip地址/webdav/</code></li>
<li>用户名   ： <code>你刚才设定的id （我们刚才设置的是myMacMini）</code></li>
<li>密码    ：  <code>你在创建过程中设置的密码</code></li>
</ul>


<p>附：完整的路径位置</p>

<p><img src="http://traximus.github.io/images/2014-01-16-03.jpeg" alt="completePath image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test Markdown]]></title>
    <link href="http://traximus.github.io/blog/2014/01/10/test-markdown/"/>
    <updated>2014-01-10T15:43:39+08:00</updated>
    <id>http://traximus.github.io/blog/2014/01/10/test-markdown</id>
    <content type="html"><![CDATA[<h1>Markdown Test</h1>

<blockquote><p>title &ndash; #</p></blockquote>

<p><img src="http://traximus.github.io/images/tx.png" alt="markdown icon" /><!--more--></p>

<blockquote><p>image &ndash; (image path)</p></blockquote>

<h2>Overview</h2>

<blockquote><p>overview title &ndash; ##</p></blockquote>

<p><strong>markdown</strong>, is so intresting.</p>

<blockquote><p>bold &ndash; **in the front of content, and anthoer 2 in the end</p></blockquote>

<h4>section1</h4>

<blockquote><p>section &ndash; ####</p></blockquote>

<h5>test table</h5>

<table>
<thead>
<tr>
<th></th>
<th>ddd1     </th>
<th>   ddd2   </th>
<th> ddd3    </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> content1</td>
<td> content2 </td>
<td>content3 |</td>
</tr>
<tr>
<td></td>
<td> cc      </td>
<td>    dd    </td>
<td> fff     |</td>
</tr>
</tbody>
</table>


<h4>section2</h4>

<ol>
<li>this is a test line</li>
<li>this is a test line</li>
<li>this is a test line</li>
</ol>


<h4>section3</h4>

<ul>
<li>this is line1</li>
<li>this is line2</li>
<li>this is line3</li>
</ul>


<h4>contact info</h4>

<p><a href="https://traximus.github.io">https://traximus.github.io</a></p>

<p><a href="https://github.com/traximus">@traximus</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello world]]></title>
    <link href="http://traximus.github.io/blog/2014/01/10/hello-world/"/>
    <updated>2014-01-10T15:09:18+08:00</updated>
    <id>http://traximus.github.io/blog/2014/01/10/hello-world</id>
    <content type="html"><![CDATA[<p>not an easy way to achieve this. f</p>
]]></content>
  </entry>
  
</feed>
