<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS_App | Traximus‘pages]]></title>
  <link href="http://traximus.github.io/blog/categories/ios-app/atom.xml" rel="self"/>
  <link href="http://traximus.github.io/"/>
  <updated>2014-07-18T11:09:26+08:00</updated>
  <id>http://traximus.github.io/</id>
  <author>
    <name><![CDATA[traximus]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[StaticCell &amp;&amp; PrototypeCell]]></title>
    <link href="http://traximus.github.io/blog/2014/07/17/staticcell-and-and-prototypecell/"/>
    <updated>2014-07-17T15:30:05+08:00</updated>
    <id>http://traximus.github.io/blog/2014/07/17/staticcell-and-and-prototypecell</id>
    <content type="html"><![CDATA[<blockquote><h4>这仍然是一篇关于   <code>storyboard</code>的笔记； 在我的项目中<code>TableView</code>使用的还是比较频繁，之前我对于自定义<code>cell</code>，一般都是新建一个<code>xib</code>，或者新建一个<code>customCell</code>类来解决；<!--more-->最近才发现，<code>storyboard</code>里面，可以直接自定义<code>cell</code>，很方便。同时提供两种类型cell， <code>static</code>， <code>prototype</code>; 下面是我关于这两种cell的简单笔记</h4></blockquote>

<hr />

<h2>1. Static Cell</h2>

<h5><code>static cell</code>, 顾名思义，就是静态cell，直接在storyboard中设置好，然后直接加载；无需再设置reuse identifier进行reuse; 当然，你可以在每一个static cell中，按照你的需要，自定义contentView；</h5>

<blockquote><p>PS1: 我这里尝试过给<code>static cell</code>添加<code>reuse identifier</code>,然后进行reuse，结果报错了；</p>

<p>PS2: 我尝试在<code>UIViewController</code>中使用<code>static cell</code>，结果发现，<code>static cell</code>只能在<code>UITableViewController</code>中使用；</p></blockquote>

<h2>2. Prototype Cell</h2>

<h4><code>prototype cell</code>，顾名思义，就是原型cell，这个cell作为一个原型，肯定可以进行reuse，当然也支持在storyboard中直接自定义contentView；</h4>

<blockquote><p>PS： prototype cell在UITableViewController和其他VC中都可以使用，没有static cell的限制；</p></blockquote>

<hr />

<h2>废话少说，我们来个基本的例子，来帮助理解；</h2>

<p><strong>首先，我们的例子app大概是这个样子；</strong></p>

<p><img src="/images/2014-07-17-01.png" alt="summary" /></p>

<p><strong>主要结构很简单，一个基于导航栏的VC，上面3个按钮，分别push到VC1, VC2，VC3</strong></p>

<ul>
<li>VC1 &ndash; 基于UITableViewController的static cell</li>
<li>VC2 &ndash; 基于UITableViewController的prototype cell</li>
<li>VC3 &ndash; 基于UIViewController的prototype cell</li>
</ul>


<h4>1.VC1 &ndash; 基于UITableViewController的static cell</h4>

<ol>
<li><p>我们先添加一个UItableViewController，然后选择static cell</p>

<p><img src="/images/2014-07-17-02.png" alt="summary" /></p></li>
<li><p>这里可以尝试尽量自定义设置属性； 比如，选中section部分，设置section header, footer， rows</p>

<p><img src="/images/2014-07-17-03.png" alt="summary" /></p></li>
<li>选择一个cell，进行一些简单的自定义（注意，这里每一个cell是互不影响，你可以单独设置每一个cell的具体属性）
<img src="/images/2014-07-17-04.png" alt="summary" /></li>
</ol>


<p>好了，VC1基本上就算完成了，你可以直接运行加载，你会发现，和我们预期的一样；</p>

<blockquote><p>PS1：如果我想让这个static cell上面的自定义按钮响应事件，或者支持编辑模式，怎么处理？ 其实这个和以前的处理方式一样：直接在对应的VC.m文件里，写上支持编辑模式的相关方法即可。 至于响应点击时间，我们直接通过IBOutlet关联事件方法就可以了。</p></blockquote>

<p>比如，我这里，对第一行cell的button关联了一个方法</p>

<p> <img src="/images/2014-07-17-05.png" alt="summary" /></p>

<blockquote><p>PS2: static cell仍然是可以自定义headerView和footerView的</p></blockquote>

<hr />

<h4>2. VC2 &ndash; 基于UITableViewController的prototype cell</h4>

<ol>
<li><p>我们先添加一个UItableViewController,然后选择prototype cell</p>

<p><img src="/images/2014-07-17-06.png" alt="summary" /></p></li>
<li><p>你会发现，你tableView上面cell，显示为prototype cells; 这里cell的数量，可以根据你的实际需要，进行添加或者减少；当然，每一行cell仍然可以完全自定义contentView； （我这里自定义了2个不同的cell，同时，<strong>需要分别设置不同的<code>reuse identifier</code></strong>）</p>

<p> <img src="/images/2014-07-17-07.png" alt="summary" />    <img src="/images/2014-07-17-08.png" alt="summary" /></p></li>
<li><p>然后，在对应的.m文件中，直接根据cell的reuse identifier即可；</p></li>
</ol>


<p>```
   &ndash; (UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{</p>

<pre><code>NSString *cellIdentifier;
if (indexPath.row!=[datasource count]-1) {
    cellIdentifier = @"prototypeCell_TableViewController";
}
else{
    cellIdentifier = @"cell2";
}
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier forIndexPath:indexPath];

// Configure the cell
CellDataModel *cellData = [datasource objectAtIndex:indexPath.row];

if (indexPath.row!=[datasource count]) {
    UILabel *titleLabel = (UILabel *)[cell viewWithTag:Label_Tag];
    UIButton *buttonT = (UIButton *)[cell viewWithTag:Button_Tag];
    UISegmentedControl *segC = (UISegmentedControl *)[cell viewWithTag:SegmengControl_Tag];
    titleLabel.text = cellData.title;
    [buttonT setTitle:cellData.buttonTitle forState:UIControlStateNormal];
    [segC setSelectedSegmentIndex:cellData.selectedIndex];
}
else{
    cell.textLabel.text = cellData.title;
    cell.detailTextLabel.text = cellData.buttonTitle;
}

return cell;
</code></pre>

<p>}</p>

<p>```</p>

<hr />

<h4>然后运行，大概就是这个样子：</h4>

<p><img src="/images/2014-07-17-09.png" alt="summary" /></p>

<h4>3. VC3  &ndash; 基于UIViewController的prototype cell</h4>

<ol>
<li>基本和VC2类似，只是UITableViewController换成了UIViewController；</li>
<li>注意，这里tableview和navgationBarItem的所处层级不一样，这个注意一下；</li>
</ol>


<hr />

<p>基本笔记就是这些了。以后有了再慢慢更新。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Storyboard相关笔记]]></title>
    <link href="http://traximus.github.io/blog/2014/05/27/storyboardxiang-guan-bi-ji/"/>
    <updated>2014-05-27T19:08:52+08:00</updated>
    <id>http://traximus.github.io/blog/2014/05/27/storyboardxiang-guan-bi-ji</id>
    <content type="html"><![CDATA[<blockquote><h4>Storyboard出来这个么长时间了，我自己使用的却不是很多，也不够熟练，这里只是简单的记录一下相关笔记，主要是搞清楚segue，scene,以及他们之间的跳转关系，部分资料也是参考别人的整理。<!--more--></h4></blockquote>

<h5>首先简单看一下</h5>

<p><img src="/images/2014-05-27-01.png" alt="summary" /></p>

<p>一个<code>Storyboard</code>管理多个<code>VC</code>，这多个<code>VC</code>就看做是多个<code>scene</code>,视图之间的跳转关系定义都可以在<code>Storyboard</code>中完成。</p>

<hr />

<h2>segue类型介绍</h2>

<p>这里的简介转载自<a href="http://www.2cto.com/kf/201210/161737.html">http://www.2cto.com/kf/201210/161737.html</a></p>

<blockquote><p>在storyboard中，segue有几种不同的类型，且iPhone和iPad对应的segue也不尽相同；</p>

<p>在iPhone中，segue有push， modal，custom三种不同类型，这些segue定义了跳转时分别对应的方式；</p>

<p>在iPad中，segue有push， modal，replace, popover， custom五种方式；</p></blockquote>

<ul>
<li>modal 模态视图，弹出的模态视图，用户只能在该View上响应，不再使用，需要dismiss</li>
<li>push  配合导航栏NavigationController一起使用，从右侧划入的方式</li>
<li>popover 浮动窗视图，iPad专用；</li>
<li>replace  替换当前scene， iPad专用</li>
<li>custom  自定义跳转方式</li>
</ul>


<hr />

<h2>Storyboard的创建</h2>

<ol>
<li>可以直接使用项目默认的storyboard，也可以自己添加多个storyboard;</li>
<li><p>获取storyboard</p>

<p><code>+ (UIStoryboard *)storyboardWithName:(NSString *)name bundle:(NSBundle *)storyboardBundleOrNil</code></p></li>
<li><p>获取storyboard中的某个VC，然后对该VC进行相应的segue操作</p>

<p><code>- (id)instantiateInitialViewController;</code></p>

<p><code>- (id)instantiateViewControllerWithIdentifier:(NSString *)identifier;</code></p></li>
<li>一个VC在被触发跳转之间，会调用下面的方法，一般进行数据传递</li>
</ol>


<p>```</p>

<pre><code>// In a storyboard-based application,  do a little preparation before navigation
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
    // used to transfer some data to new VC
    // Get the new view controller using [segue destinationViewController].
    // Pass the selected object to the new view controller.
}
</code></pre>

<p>```</p>

<ol>
<li>对于一个VC，可以使用下面的方法，来指定执行哪一个segue(如果该VC指定了多个segue)，或者查询segue是否可用</li>
</ol>


<p>```</p>

<pre><code>- (void)performSegueWithIdentifier:(NSString *)identifier sender:(id)sender

- (BOOL)shouldPerformSegueWithIdentifier:(NSString *)identifier sender:(id)sender 

// Invoked immediately prior to initiating a segue. Return NO to prevent the segue from firing.
// The default implementation returns YES. 
// This method is not invoked when -performSegueWithIdentifier:sender: is used.
</code></pre>

<p>```</p>

<ol>
<li>对于一个VC，可以指定segue类型为modal时的style</li>
</ol>


<p>```</p>

<pre><code>/*
Defines the transition style that will be used for this view controller when it is 
presented modally. Set this property on the view controller to be presented, not the presenter.
Defaults to UIModalTransitionStyleCoverVertical.
*/

@property(nonatomic,assign) UIModalTransitionStyle modalTransitionStyle NS_AVAILABLE_IOS(3_0);
@property(nonatomic,assign) UIModalPresentationStyle modalPresentationStyle NS_AVAILABLE_IOS(3_2);
</code></pre>

<p>```</p>

<pre><code>**UIModalTransitionStyle &amp;&amp; UIModalPresentationStyle 的定义为：**
</code></pre>

<p>```</p>

<pre><code>typedef NS_ENUM(NSInteger, UIModalTransitionStyle) {
    UIModalTransitionStyleCoverVertical = 0,
    UIModalTransitionStyleFlipHorizontal,
    UIModalTransitionStyleCrossDissolve,
    UIModalTransitionStylePartialCurl,
};

typedef NS_ENUM(NSInteger, UIModalPresentationStyle) {
    UIModalPresentationFullScreen = 0,
    UIModalPresentationPageSheet,
    UIModalPresentationFormSheet,
    UIModalPresentationCurrentContext,
    UIModalPresentationCustom,
    UIModalPresentationNone = -1,               
};
</code></pre>

<p>```</p>

<hr />

<h2>Storyboard的简单使用</h2>

<ol>
<li><p>一般情况下，一个storyboard至少管理者一个scene，对于VC之间的跳转segue可以直接从能触发的控件，
按住Control，然后连接到另一个你需要跳转的VC上，记住，你最好给segue设置一个identifier。</p></li>
<li><p>同时，你可以不指定segue，只给某一个VC指定一个Storyboard ID, 在使用的时候，直接调用下面的方法来获取VC</p>

<p> <code>- (id)instantiateViewControllerWithIdentifier:(NSString *)identifier;</code></p></li>
</ol>


<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用instruments]]></title>
    <link href="http://traximus.github.io/blog/2014/02/11/ru-he-shi-yong-instruments/"/>
    <updated>2014-02-11T16:03:08+08:00</updated>
    <id>http://traximus.github.io/blog/2014/02/11/ru-he-shi-yong-instruments</id>
    <content type="html"><![CDATA[<blockquote><p>源地址：<a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode">http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode</a></p></blockquote>

<hr />

<h2>学习使用Xcode的instruments工具来定位问题，优化你的app</h2>

<p>在你的iOS开发生涯中，你或许已经已经做过1到2个app，而且也明白如何做的更好。在给你的app添加新功能和特性的同时，你也应该注意另外一件事：使用<code>instruments</code>帮助优化你的app.</p>

<p>这篇教程将会讲解如何使用<code>instruments</code>工具的重要功能来配合<code>Xcode</code>优化你的app，他可以帮你检查关于性能，内存泄漏以及其他问题。<!--more--></p>

<p><img src="/images/2014-02-11-01.png" alt="instruments" /></p>

<p><strong>这篇文章中，你会接触到以下内容：</strong></p>

<ul>
<li>使用<code>Allocations</code> 以及 <code>Leaks</code>来检测并修复你代码中的内存管理问题</li>
<li>使用<code>Time Profiler</code>定位你代码中的<code>hot-spots</code>,并教你如何让你的代码更加有效率；</li>
</ul>


<blockquote><p>注意：这篇教程的前提是你已经熟悉<code>Objective_C</code>和iOS开发相关知识，如果你是初学者，你可以看看其他的<a href="http://www.raywenderlich.com/tutorials">教程</a>;另外，本使用了<code>Xcode5</code>以及<a href="http://www.raywenderlich.com/5138/beginning-storyboards-in-ios-5-part-1">storyboard</a>，你应该已经熟知相关内容。</p></blockquote>

<p>一切就绪，让我们一起沉侵于Instruments的奇妙世界！</p>

<hr />

<p>```
instruments的打开途径有2种：</p>

<ol>
<li>Xcode菜单栏->Product->Profile                                  用来分析当前Xcode项目</li>
<li>Dock栏，右键单击Xcode图标->Open Developer Tools->Instruments     可以用来检测指定app的信息
```</li>
</ol>


<hr />

<h2>初步工作</h2>

<p>这篇教程为你提供了一个示例项目，我们将一步一步的按照教程，使用instruments对整个项目进行优化。<a href="http://cdn4.raywenderlich.com/downloads/InstrumentsTutorial.zip">你可以从这里下载</a></p>

<p>下载项目以后，编译运行（假设我们输入关键字dog，搜索，然后点击results,可以看到类似于下面的页面：）</p>

<p><img src="/images/2014-02-11-02.png" alt="search results of 'dog'" /></p>

<p>大致浏览一下app，这个app的基本功能就是搜索flickr的照片，并进行展示。顶部有一个search bar，你输入关键字，进行搜索以后，会有一个results结果，点击结果，显示一个新的table，同时显示搜索到图片的预览。单击某一个图片预览，就会进入一个新页面，展示该图片；</p>

<p>目前为止，一切和预期的一样，看起来没什么问题。无论如何，接下来你讲看到如何使用instruments发现这个app中众多潜在的问题，并进行调试优化，你会发现整个过程比你想象的要容易一些。</p>

<hr />

<h2>开始分析</h2>

<p>许多开发者在规划app的时候，总是充满了丰富的奇思妙想 &ndash; 事实上也确实是非常有价值的目标。然后他们阅读了一些类似于“过早优化”的类容，并且想知道如何避免这些糟糕的情况。</p>

<p>从某种程度上来说，你可以在你的开发流程之外进行你的优化工作。现在的移动设备已经足够强大，但是作为开发者，你不能总是依赖于提升硬件和处理处速度来粉饰你app那超低的效率。</p>

<p><strong>分析，要找对合适的地方</strong></p>

<p>你可以花一个星期的时间微调某一个有趣的算法，但是如果这个算法只占总执行时间的0.5%，那么没有人会注意到其中的差别；但是另一方面，如果你花费大量精力去优化你程序所使用到的很耗时的循环，即使你只取得了10%的改善，效果会非常明显。</p>

<h4>Time Profiler</h4>

<p>跟踪记录每一个method的CPU时间消耗，或者每一个线程的栈情况，先睹为快：</p>

<p><img src="/images/2014-02-11-03.png" alt="Time Profiler" /></p>

<p><img src="/images/2014-02-11-04.png" alt="Time Profiler" /></p>

<p>这张图片显示了每一个线程的call stack，每一level或者frame,在被调用后，不同methods在程序中的调用路径，以及CPU当前执行到的位置 &ndash; 也就是frame 0。每一个method的时间消耗都可以从profiler进入该method的次数来判断。</p>

<p>取个例子：如果有100份会消耗1毫秒的样本，而某一个method中在stack中调用了10份样本的话，你就可以粗略的推断出这个method会消耗10毫秒，这虽然是个近似值，但是很管用！</p>

<p><strong>事不宜迟，现在开始使用instruments来进行分析</strong>
打开例子项目，在Xcode的菜单栏，<code>Product</code>&ndash;><code>Profile</code>，进入instruments界面。
选择<code>Time Profiler</code>&ndash;><code>Profiler</code>，然后会在模拟器中运行app（这里可能还需要你输入密码，输入即可）</p>

<p>现在，开始在模拟器中使用app，输入搜索关键字，在得到搜索结果以后，点击进入结果列表，直接滑动结果列表，或者点击查看一张image，你会发现，app反应非常的慢，真是太糟糕了！</p>

<p>幸运的是，我们可以修复这个问题。首要目标就是找对instruments中相对应的分析器（确保instruments的View同时选中了这3种模式）
<img src="/images/2014-02-11-05.png" alt="instruments view option" /></p>

<p>下面是instruments Time Profiler的主要区域</p>

<p><img src="/images/2014-02-11-06.jpeg" alt="instruments Time Profiler Main section" /></p>

<ol>
<li>开始 &amp; 结束</li>
<li>app运行计时器 &ndash; 时间表示app本次进行profile运行的时间， <code>Run 1 of 1</code>表示app运行的次数（如果你stop后再重新start，会显示 <code>Run 2 of 2</code>）</li>
<li>app运行消耗轨迹 &ndash; 在Time Profiler状态，能清晰的表示出app的时间消耗</li>
<li>扩展的详细面板 &ndash; 在Time Profiler状态，主要显示instruments记录的栈记录</li>
<li>详细面板 &ndash; 主要展示了methods的时间消耗情况，可以简单的分析哪一个method占用了更多的CPU时间；当你点击某一个具体的method时，扩展面板会显示相应的栈记录</li>
<li>option面板</li>
</ol>


<hr />

<h2>深入挖掘</h2>

<p>执行一次搜索，当获取到搜索结果以后，多尝试几次上下滑动；然后可以暂停Time Profiler，你会看到，刚才标记为3的区域，记录了很多CPU时间消耗.为了查明问题所在，你需要设置更多的Time Profiler选项。</p>

<p>左下区域，选择<code>Separate by Thread</code>, <code>Invert Call Tree</code>, <code>Hide System Libraries</code> ,  <code>Show Obj-C Only</code></p>

<p><img src="/images/2014-02-11-10.png" alt="instruments Time Profiler option" /></p>

<ul>
<li>Separate by Thread   : 单独区分每一个线程，让你能查看每一个线程的CPU消耗情况</li>
<li>Invert Call Tree     : 让被调用的method处于frame0位置，可以直观的看到调用的最深层次的method</li>
<li>Hide Missing Symbols : 当找不到dSYM文件时，此选项能帮助你仅显示完整识别的method名，其余method隐藏</li>
<li>Hide System Libraries: 仅显示你来自于你app的method信息（系统对CPU消耗，你无能为力）</li>
<li>Show Obj-C Only      : 仅显示Objective-C method</li>
<li>Flatten Recursion    : 对于递归method，仅作为一个入口，而不是多个</li>
<li>Top Functions        : 开启此功能，会对method的CPU占用时间做和统计（比如：A调用了B,那么统计A的时间时就会算上B的时间）</li>
</ul>


<p>设置Time Profiler之前
<img src="/images/2014-02-11-07.png" alt="before Time Profiler option" /></p>

<p>设置Time Profiler之后
<img src="/images/2014-02-11-08.png" alt="after Time Profiler option" /></p>

<p>仔细查看设置后的详细信息区域，发现CPU时间消耗，大部分都在<code>-[PhotoCell setPhoto:]</code>方法中，因为在tableView进行滚动的时候，cell一直在更新，而cell显示的photo也一直需要update；为了搞清楚具体情况，双击<code>-[PhotoCell setPhoto:]</code>，会看到下面的代码(我这里得到的信息和原文有点出入，我以实际情况为准)</p>

<p><img src="/images/2014-02-11-09.png" alt="PhotoCell setPhoto:" /></p>

<p><strong>如你所见，时间主要花在这两个部分：获取image data &amp;&amp; create image，这就是问题所在：</strong></p>

<ul>
<li><p>[NSData dataWithContentsOfURL: 在data被下载之前会一直block（不返回），而且由于运行在main thread里面，会block UI，每一次请求都会花费一定时间,所以滑动的时候，多次请求就会让整个滑动过程非常糟糕。</p>

<p>解决的办法是异步加载image数据；点击instruments的这个位置（会自动打开Xcode，定位到相应的文件和代码区域）</p>

<p><img src="/images/2014-02-11-11.jpeg" alt="open Xcode:" />
然后代码作如下改动</p></li>
</ul>


<p>```
  &ndash;(void)setPhoto:(FlikrPhoto *)photo
  {</p>

<pre><code>_photo = photo;
self.textLabel.text = photo.title;

// NSData *imageData = [NSData dataWithContentsOfURL: _photo.thumbnailUrl];
// self.imageView.image = [UIImage imageWithData: imageData];

[[ImageCache sharedInstance] downloadImageAtURL: _photo.thumbnailUrl
                                completionHandler:^(UIImage *image){
                                    self.imageView.image = image;
                                    [self setNeesLayout];
                                }];
</code></pre>

<p>  }</p>

<p>```</p>

<p>  然后再执行<code>Product</code>&ndash;><code>Profile</code>&ndash;><code>Time Profiler</code>&ndash;><code>Profile</code>,搜索，然后在结果列表界面进行滑动，你会发现，上下滑动结果的时候，顺畅多了。<strong>接下来，我们能优化更多</strong>；</p>

<hr />

<blockquote><p>关于 memory leaks(内存泄露),主要有2种。第一种我们叫做真实的memory leak(一个object在不再使用后没有被deallocated，导致这部分内存不能被重新使用)； 另一种就有点意思了，我们叫做<code>unbounded memory growth(无限制的内存增长)</code>，这种情况下，会不停的allocate内存但是一致没有机会被deallocated;
memory leaks是非常严重的问题，因为他可能在某个时间导致耗尽你的系统内存，从而被iOS的系统watch dog关闭你的app；</p></blockquote>

<hr />

<h2>超级重要的Allocations</h2>

<p>接下来，我们会使用Allocations仪器，帮助我们分析每一个object的内存分配和管理，当然也可以查看到一个object的内存计数器。</p>

<p><code>Product</code>&ndash;><code>Profile</code>&ndash;><code>Allocations</code>&ndash;><code>Profile</code></p>

<p><img src="/images/2014-02-11-12.png" alt="Allocations" /></p>

<p>app会自动运行，然后你会看到类似于下面的情况</p>

<p><img src="/images/2014-02-11-13.png" alt="Allocations" /></p>

<p>这里你需要关注2大主要的跟踪记录：<code>Allocations</code>和<code>VM Tracker</code>；Allocations我们将会在接下来的时间详细讲解， VM Tracker也非常有用，只是稍微复杂一点。</p>

<p><strong>我们做下面的实验，来找出例子项目中的内存问题：</strong></p>

<p><em>进行10次不同关键字的搜索（进入结果列表但是不要进入具体图片界面），确保每次搜索都有一些结果；然后让app等待几秒钟</em>；</p>

<p>你应该已经注意到了，<code>Allocations</code>区域的图表记录一直在增长，也就是说，app在allocate新的内存；现在，我们需要尝试进行<strong><code>heap shot analysis</code></strong>：运行app的同时，点击左侧区域的<code>Mark Generation</code>按钮；</p>

<p><code>
heap信息快照，主要是为了多次执行同一个操作，观察内存是否无限制的增长（这里我们点击一个搜索结果，然后等待图片加载，
加载完毕以后，再换另一个搜索结果，再点击进入等待图片加载，如此返回，对多个搜索结果进行测试）
你会看到类似于下面的情况：
</code>
<img src="/images/2014-02-11-14.png" alt="Mark Generation" /></p>

<p>通过上面的图，发现了一些问题：每次重新选择一个搜索结果，点击进入，图片加载以后再切换另一个搜索结果，内存总是在不停的增长；</p>

<p>我们都知道，iOS系统有一个内存警告方法，当系统内存吃紧的时候，会发送这个消息，app可以在这个方法里面释放不需要的内存；我们可以在iOS模拟器里面模拟这个内存警告（硬件->模拟内存警告）.你会发现，内存确实骤降了一些，但是远远达不到我们的要求，肯定还有其他什么地方存在着内存问题。</p>

<hr />

<h2>查找内存消耗大户 &ndash; 无约束的内存增长</h2>

<p>第一次<code>Mark Generation</code>产生的数据作为一个基准，后面每一次<code>Mark Generation</code>产生的数据，都是以前面的mark作为参考对象，所以，你可以通过查看<code>Growth</code>这一列来看看，新增长了多少内存，展开查看到底哪些内存是新增的。</p>

<h5>展开其中一次记录，你会看到有如此多的objects，怎么处理呢？</h5>

<p>最好的方式，是查看你app直接使用的class相关信息，这个例子中，类似于<code>HTTPHeaderDict</code>, <code>CGRegion</code>, <code>CGPath</code>, <code>CFNumber</code>之类的对象，可以暂时忽略掉。</p>

<p>我们关注一下ImageCache（或者UIImage）,因为你的app直接处理该类；找到ImageCache这个类，展开，可以在右边的详细面板看到具体信息</p>

<p><img src="/images/2014-02-11-15.png" alt="Mark Generation detail" /></p>

<h5>具体分析</h5>

<p>右边的项目信息中，灰色部分是system library, 黑色部分是我们app的method,你可以双击黑色部分，进入到相应的代码段；我们来看这一段代码：</p>

<p>```
&ndash; (void)downloadImageAtURL:(NSURL*)url completionHandler:(ImageCacheDownloadCompletionHandler)completion {</p>

<pre><code>UIImage *cachedImage = [self imageForKey:[url absoluteString]];
if (cachedImage) {
    completion(cachedImage);
} else {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSData *data = [NSData dataWithContentsOfURL:url];
        UIImage *image = [UIImage imageWithData:data];
        [self setImage:image forKey:[url absoluteString]];
        dispatch_async(dispatch_get_main_queue(), ^{
            completion(image);
        });
    });
}
</code></pre>

<p>}
```
在这个方法内部，有一个[setImage: forKey:]方法，这个方法是将一个image对象存储到cache字典里，以防止再次使用（这就是问题所在，所以新的image出现以后，内存会不断的增长），现在我们来看这个方法实现：</p>

<p>```
&ndash; (void)setImage:(UIImage<em>)image forKey:(NSString</em>)key {</p>

<pre><code>[_cache setObject:image forKey:key];
</code></pre>

<p>}
```
这个方法就是以url为key，把image添加到cache字典里，但是我们注意到，image没有在任何地方release(问题出现在这里); cache只会添加新的image但是从来不会清除cache，多以会导致内存“无约束增长”（前面说到的第二种类型内存问题）;</p>

<p>我们可以这样修复他：为imageCache这个类，添加监听memoryWarning的方法，当收到内存警告时，就清除cache；</p>

<p>```
//添加通知监听
&ndash; (id)init {</p>

<pre><code>if ((self = [super init])) {
    _cache = [NSMutableDictionary new];
    [[NSNotificationCenter defaultCenter] addObserver:self 
                                selector:@selector(memoryWarning:)        
                                name:UIApplicationDidReceiveMemoryWarningNotification object:nil];
}
return self;
</code></pre>

<p>}</p>

<p>//进行相应的处理
&ndash; (void)memoryWarning:(NSNotification*)note {</p>

<pre><code>[_cache removeAllObjects];
</code></pre>

<p>}
<code>``
**处理完毕，为了确保已经修复这个问题，我们关闭instruments，再次重新进入</code>Allocations<code>，和之前差不多，先搜索多个不同的关键字，然后先</code>Mark Generation<code>-&gt;选择一个结果-&gt;进入结果列表-&gt;等待图片加载完毕-&gt;【模拟内存警告】，再</code>Mark Generation`&ndash;>选择另一个结果并接入结果列表->等待图片加载->【模拟内存警告】；如此反复；如果内存没有像之前那样不停的增长，那么，我们搞定他了。**</p>

<p>这是我这实际测试的情况</p>

<p><img src="/images/2014-02-11-16.png" alt="Mark Generation" /></p>

<hr />

<h2>查找对象的memory leaks &ndash; 真实的内存泄露</h2>

<p>现在，我们来查找一下app中的第一种类型内存问题（一个object不再使用以后，没有得到释放）</p>

<p>在Xcode菜单栏，<code>Product</code>&ndash;><code>Profile</code>&ndash;><code>Leaks</code>&ndash;><code>Profile</code>；</p>

<p><img src="/images/2014-02-11-17.png" alt="Leaks" /></p>

<p><code>Leaks</code>仪器主要包含2种类型记录：<code>Allocations</code>和<code>Leaks</code>;其中的<code>Allocations</code>仪器和之前使用的一样，现在需要着重关注<code>Leaks</code></p>

<p><img src="/images/2014-02-11-18.png" alt="Leaks window" /></p>

<p>上图中，你会看到，默认的<code>Automatic Snapshotting</code>已经被选中，也就是说，只要有内存泄露，就会立即反应出来（上图中的红色竖线标记位置）；默认的自动记录时间间隔是10秒，你也可以随时按下<code>Snapshot Now</code>按钮在记录当前数据.</p>

<p><img src="/images/2014-02-11-19.png" alt="Snapshot" /></p>

<h5>找到内存泄露并搞定他</h5>

<p>运行app，执行搜索，进入搜索结果，点击进入某一张图片页面，然后执行<code>Rotate</code>操作，你会看到红色竖线标记的内存泄露。现在，我们打开扩展信息面板，你会看到类似于下面的信息：</p>

<p><img src="/images/2014-02-11-20.png" alt="Leaks extend detail info" /></p>

<p>所有问题都指向<code>rotateTapped</code>这个方法，我们现在来仔细的研究一个这段代码</p>

<p>```
&ndash; (void)rotateTapped:(id)sender {</p>

<pre><code>UIImage *currentImage = _imageView.image;
CGImageRef currentCGImage = currentImage.CGImage;

CGSize originalSize = currentImage.size;
CGSize rotatedSize = CGSizeMake(originalSize.height, originalSize.width);

CGContextRef context = CGBitmapContextCreate(NULL,
                                             rotatedSize.width,
                                             rotatedSize.height,
                                             CGImageGetBitsPerComponent(currentCGImage),
                                             CGImageGetBitsPerPixel(currentCGImage) * rotatedSize.width,
                                             CGImageGetColorSpace(currentCGImage),
                                             CGImageGetBitmapInfo(currentCGImage));

CGContextTranslateCTM(context, rotatedSize.width, 0.0f);
CGContextRotateCTM(context, M_PI_2);
CGContextDrawImage(context, (CGRect){.origin=CGPointZero, .size=originalSize}, currentCGImage);

CGImageRef newCGImage = CGBitmapContextCreateImage(context);
UIImage *newImage = [UIImage imageWithCGImage:newCGImage];

self.imageView.image = newImage;
</code></pre>

<p>}
```</p>

<p><strong>很多人都认为<code>ARC</code>能够处理好内存相关问题，只要使用了<code>ARC</code>，其他就不用管了；但事实上，<code>ARC</code>仅仅能正确地管理<code>Objective-C</code>对象，而上述代码中的<code>CoreFoundation</code>对象，就必须手动管理了。</strong></p>

<blockquote><p>CoreFoundation对象的内存管理规则：create,copy是拥有该对象，不再使用时，需要CFRelease();其他方式不需要释放；另外，当把一个object传递到一个方法中的时候，receiver不拥有该参数对象，因此该object可能在任何时间被deallocate掉，这个时候，receiver可以使用CFRetain（）主动维护该object; 另外，CF对象的拷贝，推荐使用CFXXCreateCopy()方法，而不是mutable拷贝（其中的XX表示类型，比如CFStringCreateCopy）</p></blockquote>

<p>现在检查一下上面的代码段，你会发现，<code>context</code>和<code>newCGImage</code>没有进行相应的释放;因为，在上述方法结束前添加下面的代码：</p>

<p><code>
CGImageRelease(newCGImage);
CGContextRelease(context);
</code></p>

<p>OK，现在重新编译，运行app，在<code>Leaks</code>中检查，执行rotate操作，你会发现没有内存泄露了。我们搞定他了！</p>

<hr />

<h2>接下来你可以干点什么</h2>

<p>你应该尽量让instruments称为你开发流程的一部分，以确保你开发出牛逼而有用的app！</p>

<hr />

<h4>这篇文章主要是讲解如何使用instruments来诊断app中可能存在的问题，主要是优化CPU时间消耗，查找潜在的内存问题并修复他们。由于我自己对Instruments也不是很熟悉，所以这是我自己的学习笔记，并没有完全按照原文翻译。原文使用的Xcode4版本，我使用的Xcode5所以存在少量的出入。上面的过程已经经过我自己的实践，希望能帮助到其他同学。</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习CoreGraphics]]></title>
    <link href="http://traximus.github.io/blog/2014/01/22/xue-xi-coregraphics/"/>
    <updated>2014-01-22T20:03:43+08:00</updated>
    <id>http://traximus.github.io/blog/2014/01/22/xue-xi-coregraphics</id>
    <content type="html"><![CDATA[<blockquote><h4>前段时间看了一些CoreGraphics资料，对CoreGraphics有了一定程度的认识，了解了基本用法，能实现一些简单的绘制功能。同时还在源地址发现了另一个东西PaintCode,能帮助实现自定义控件，同时我个人感觉PaintCode生成的代码，可读性还不错，也可以作为学习CoreGraphics的一种方式。<!--more--></h4></blockquote>

<hr />

<h2>CoreGraphics</h2>

<h4>1. <a href="http://www.raywenderlich.com/32283/core-graphics-tutorial-lines-rectangles-and-gradients">Lines,Rectangles, and Gradients</a></h4>

<h4>2. <a href="http://www.raywenderlich.com/32925/core-graphics-tutorial-shadows-and-gloss">Shadows and Gloss</a></h4>

<h4>3. <a href="http://www.raywenderlich.com/33193/core-graphics-tutorial-arcs-and-paths">Arcs and Paths</a></h4>

<h4>4. <a href="http://www.raywenderlich.com/33330/core-graphics-tutorial-glossy-buttons">Glossy Buttons</a></h4>

<h4>5. <a href="http://www.raywenderlich.com/33496/core-graphics-tutorial-patterns">Patterns</a></h4>

<h4>6. <a href="http://www.raywenderlich.com/34003/core-graphics-tutorial-curves-and-layers">Curves and Layers</a></h4>

<h4>7. How to Create a PDF with Quartz2D in iOS 5</h4>

<ul>
<li><a href="http://www.raywenderlich.com/6581/how-to-create-a-pdf-with-quartz-2d-in-ios-5-tutorial-part-1">part1</a></li>
<li><a href="http://www.raywenderlich.com/6818/how-to-create-a-pdf-with-quartz-2d-in-ios-5-tutorial-part-2">part2</a></li>
</ul>


<h4>8. <a href="http://www.raywenderlich.com/18840/how-to-make-a-simple-drawing-app-with-uikit">How to Make a Simple Drawing App with UIKit</a></h4>

<hr />

<h2>PaintCod径</h2>

<h4>1. <a href="http://www.raywenderlich.com/36341/paintcode-tutorial-dynamic-buttons">绘制动态按钮</a></h4>

<h4>2. <a href="http://www.raywenderlich.com/35720/paintcode-tutorial-custom-progress-bar">绘制自定义的ProgressBar</a></h4>

<h4>3. <a href="http://www.raywenderlich.com/38918/paintcode-tutorial-bezier-paths">绘制贝塞尔曲线</a></h4>

<hr />

<p><strong>PS1: 这是CoreGraphics一些列相关资料，循序渐进的学习，效果会比较不错;其中小部分文章有中文，其余是英文，如果有时间，我可以用我蹩脚的英语翻译一下。</strong></p>

<p><strong>PS2: 我记得其中PaintCode一篇生成的code是有问题的，可能是PaintCode的版本不一样导致的？我在实践的时候，发现好像是一个rect不对（时间有点久，从老blog搬过来的，实在记不起了>_&lt;），实践的时候可能稍微注意一下。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Performance Tips&amp;Tricksks]]></title>
    <link href="http://traximus.github.io/blog/2014/01/21/ios-performance-tips-and-tricksks/"/>
    <updated>2014-01-21T11:09:33+08:00</updated>
    <id>http://traximus.github.io/blog/2014/01/21/ios-performance-tips-and-tricksks</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks">http://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks</a></p></blockquote>

<p>app拥有良好的性能非常重要，这是保证良好用户体验的基石。这篇文章是基于原文，我自己的备忘记录。<!--more--></p>

<hr />

<h2>1.ARC</h2>

<p>新项目现在一般都是基于ARC了，就算使用ARC，很多情况下，还是会有内存泄露的情况存在，所以使用instrument就很必要了。</p>

<p><strong>如何使用instrument：英文<a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode">http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode</a></strong></p>

<p><strong>如何使用instrument：中文<a href="http://traximus.github.io/blog/2014/02/11/ru-he-shi-yong-instruments/">http://traximus.github.io/blog/2014/02/11/ru-he-shi-yong-instruments/</a></strong></p>

<hr />

<h2>2.Reuse</h2>

<h4>1)reuseidentifier</h4>

<ul>
<li>UITableViewCell</li>
<li>UICollectionViewCell</li>
<li>UITableViewHeaderFooterViews</li>
</ul>


<h4>2)Resue &amp;&amp; Lazy load</h4>

<p>学习UITableView的方式，不要一次性创建所有的subView,你只在需要的时候创建subView,并把它添加到reuse Queue;这可以避免大量的消耗。想啊次使用的时候，你只需要reuse即可。</p>

<h4>3)reuse Expensive object</h4>

<p>类似与NSDateFormatter, NSCalendar，这些object的初始化，设置效率比较低，代价比较大。针对这种情况，应该考虑重用。</p>

<p><strong>应对的做法有2种：</strong></p>

<ul>
<li>添加为class的变量，进行reuse</li>
<li>创建一个static variable</li>
</ul>


<p>对于第二种情况，你应该写一个类似与singleton的方法，来获取这个object</p>

<p>```
&ndash;(NSDateFormatter *)fotmatter
{</p>

<pre><code>static NSDateFormatter *formatter;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    _formatter = [[NSDateFormatter alloc] init];
    _formatter.dateFormat = @"EEE MMM dd HH:mm:ss Z yyyy";//twitter date format
});

return formatter;
</code></pre>

<p>}
```</p>

<hr />

<h2>3.set <code>opaque</code> to YES</h2>

<p>default</p>

<hr />

<h2>4.Avoid fat XIBs</h2>

<p>因为在XIB初始化的时候，会直接加载所有内容到内存中，增加大量的开销。因此，尽量把XIB拆分开，只在需要的时候在初始化并进行加载，这样就可以避免一次性加载国语复杂的xib所导致的内存和cpu过量消耗；</p>

<p>当然，现在很多项目使用stroyboard在一定程度上已经缓解了这个问题。</p>

<hr />

<h2>5.DO NOT block Main Thread</h2>

<ul>
<li>GCD</li>
<li>[NSURLConnection sendAsynchronousRequest: completionHandler:]</li>
</ul>


<hr />

<h2>6.<code>Size image</code> to imageVew&rsquo;s size</h2>

<p>事实上，将一个image放入到imageview中，并进行sizeToFit是有很大开销的,而且这部分开销可以避免；
当我们获取到image后，最好先进行resize,然后再放入到合适的imageView中；</p>

<hr />

<h2>7. Choose right data format and structure</h2>

<h4>1)choose <code>correct collection</code></h4>

<ul>
<li>NSArray：<strong>ordered</strong> list of values, <strong>Quick lookup</strong> by <strong>index</strong>, <strong>Slow lookup</strong> by <strong>value</strong>；<strong>Slow</strong> to insert&amp;delete</li>
<li>NSDictionary：key-value pairs, <strong>Quick lookup</strong> by <strong>key</strong></li>
<li>NSSet：unordered list of values, <strong>Quick lookup</strong>by <strong>value</strong>, <strong>Quick</strong> insert&amp;delete</li>
</ul>


<h4>2)choose <code>right data format</code></h4>

<ul>
<li>JSON &ndash; faster to parse, smaller than XML</li>
<li>XML &ndash; soap advantage</li>
</ul>


<h4>3)choose <code>corrent data storage option</code></h4>

<ul>
<li>NSUserDefaults    &ndash;   small data</li>
<li>XML,JSON,Plist    &ndash;   expensive operation to store and parse</li>
<li>NSCoding (archive)&ndash;   expensive as above</li>
<li>sqlite            &ndash;   easy to use</li>
<li>Core Data         &ndash;   like above</li>
</ul>


<hr />

<h2>8.enable GZIP compression</h2>

<hr />

<h2>9.cache</h2>

<p>对于不会变化，并且经常使用到的object进行cache; 对于http cache, 基本的第三方库都已经实现了cache; 对于一般的object，可以使用NSCache:<a href="http://nshipster.com/nscache/">http://nshipster.com/nscache/</a></p>

<hr />

<h2>10. Drawing performance</h2>

<p>考虑不同的绘图机制的性能</p>

<ul>
<li>UIKit</li>
<li>Core Animation</li>
<li>Core Graphics(相对于其他而言，更加高效)</li>
</ul>


<p>//绘制 Shadow Path</p>

<p><code>
//CoreAnimation - 这种方式代价高昂
UIView *view= [[UIView alloc] init];
view.layer.shadowOffst = CGSizeMake(-1.0, 1.0);
view.layer.shadowRadius = 5.0;
view.layer.shadowOpacity = 0.6;
</code></p>

<p><code>
//effective way
view.layer.shadowPath = [[UIBezierPath bezierPathWithRect: view.bounds] CGPath];
</code></p>

<hr />

<h2>11.处理Memory Warnings</h2>

<p>常见有3中方式接收到memory warning</p>

<ol>
<li>applicationDidReceiveMemoryWarning: appDelegate</li>
<li>didReceiveMemoryWarning：           UIViewController</li>
<li>UIApplicationDidReceiveMemoryWarningNotification：notificationCenter</li>
</ol>


<hr />

<h2>12.Avoid Re-Processing Data</h2>

<p>这主要是数据出库的逻辑需要规划好</p>

<hr />

<h2>13. background image</h2>

<ul>
<li>full size image &ndash; [UIImage imageNamed:@&ldquo;test.png&rdquo;];</li>
<li>pattern image &ndash; [UIColor colorWithPatternImage:[UIImage imageNamed:@&ldquo;test.png&rdquo;]];</li>
</ul>


<hr />

<h2>14.reduce your web footprint</h2>

<p>尽量减少javascript的使用</p>

<hr />

<h2>15.Optimize tableview</h2>

<ul>
<li>reuse cell</li>
<li>set subview opaque</li>
<li>avoid gradients, image scale, offscreen drawing</li>
<li>cache height if height is variable</li>
<li>use asynchronously method for cell' contents</li>
<li>use shadowPath to set shadow</li>
<li>reduce te number of subViews</li>
<li>do as little work possible in <code>cellForRowAtIndexPath:</code></li>
<li>use the appropriate data structure</li>
<li>use <code>rowHeight</code>, <code>sectionFooterHeight</code>,<code>sectionHeaderHeight</code> to set constant height instead of delegte(效率上能理解，设计上我自己暂时不是很理解这条)</li>
</ul>


<hr />

<h2>16.speed up Launch time</h2>

<p>注1：异步获取数据，延迟加载，避免臃肿的xib</p>

<p>注2：测试Launch time最有效的方式是，断开Xcode,单独运行你的app</p>

<hr />

<h2>17.image load</h2>

<ul>
<li>imageNamed:               &ndash;   首先从system cache里面查找该image，如果没有找到，再从文件加载image</li>
<li>imageWithContentsOfFile:  &ndash;   直接从文件加载image,不检查system cache</li>
</ul>


<p>注意：对于会多次使用到的image，选择imageNamed：更加合适，因为system cache会进行cache; 而对于单次使用的image，直接从文件加载的imageWithContentsOfFile:更加合适</p>

<hr />

<p>上面的知识点只是针对我个人做备忘，每一个人对此的理解不一样，因此建议看看原文。</p>
]]></content>
  </entry>
  
</feed>
