<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS_App | Traximus‘pages]]></title>
  <link href="http://traximus.github.io/blog/categories/ios-app/atom.xml" rel="self"/>
  <link href="http://traximus.github.io/"/>
  <updated>2014-01-23T16:22:34+08:00</updated>
  <id>http://traximus.github.io/</id>
  <author>
    <name><![CDATA[traximus]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[学习CoreGraphics]]></title>
    <link href="http://traximus.github.io/blog/2014/01/22/xue-xi-coregraphics/"/>
    <updated>2014-01-22T20:03:43+08:00</updated>
    <id>http://traximus.github.io/blog/2014/01/22/xue-xi-coregraphics</id>
    <content type="html"><![CDATA[<blockquote><h4>前段时间看了一些CoreGraphics资料，对CoreGraphics有了一定程度的认识，了解了基本用法，能实现一些简单的绘制功能。同时还在源地址发现了另一个东西PaintCode,能帮助实现自定义控件，同时我个人感觉PaintCode生成的代码，可读性还不错，也可以作为学习CoreGraphics的一种方式。<!--more--></h4></blockquote>

<hr />

<h2>CoreGraphics</h2>

<h4>1. <a href="http://www.raywenderlich.com/32283/core-graphics-tutorial-lines-rectangles-and-gradients">Lines,Rectangles, and Gradients</a></h4>

<h4>2. <a href="http://www.raywenderlich.com/32925/core-graphics-tutorial-shadows-and-gloss">Shadows and Gloss</a></h4>

<h4>3. <a href="http://www.raywenderlich.com/33193/core-graphics-tutorial-arcs-and-paths">Arcs and Paths</a></h4>

<h4>4. <a href="http://www.raywenderlich.com/33330/core-graphics-tutorial-glossy-buttons">Glossy Buttons</a></h4>

<h4>5. <a href="http://www.raywenderlich.com/33496/core-graphics-tutorial-patterns">Patterns</a></h4>

<h4>6. <a href="http://www.raywenderlich.com/34003/core-graphics-tutorial-curves-and-layers">Curves and Layers</a></h4>

<h4>7. How to Create a PDF with Quartz2D in iOS 5</h4>

<ul>
<li><a href="http://www.raywenderlich.com/6581/how-to-create-a-pdf-with-quartz-2d-in-ios-5-tutorial-part-1">part1</a></li>
<li><a href="http://www.raywenderlich.com/6818/how-to-create-a-pdf-with-quartz-2d-in-ios-5-tutorial-part-2">part2</a></li>
</ul>


<h4>8. <a href="http://www.raywenderlich.com/18840/how-to-make-a-simple-drawing-app-with-uikit">How to Make a Simple Drawing App with UIKit</a></h4>

<hr />

<h2>PaintCod径</h2>

<h4>1. <a href="http://www.raywenderlich.com/36341/paintcode-tutorial-dynamic-buttons">绘制动态按钮</a></h4>

<h4>2. <a href="http://www.raywenderlich.com/35720/paintcode-tutorial-custom-progress-bar">绘制自定义的ProgressBar</a></h4>

<h4>3. <a href="http://www.raywenderlich.com/38918/paintcode-tutorial-bezier-paths">绘制贝塞尔曲线</a></h4>

<hr />

<p><strong>PS1: 这是CoreGraphics一些列相关资料，循序渐进的学习，效果会比较不错;其中小部分文章有中文，其余是英文，如果有时间，我可以用我蹩脚的英语翻译一下。</strong></p>

<p><strong>PS2: 我记得其中PaintCode一篇生成的code是有问题的，可能是PaintCode的版本不一样导致的？我在实践的时候，发现好像是一个rect不对（时间有点久，从老blog搬过来的，实在记不起了>_&lt;），实践的时候可能稍微注意一下。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Performance Tips&amp;Tricksks]]></title>
    <link href="http://traximus.github.io/blog/2014/01/21/ios-performance-tips-and-tricksks/"/>
    <updated>2014-01-21T11:09:33+08:00</updated>
    <id>http://traximus.github.io/blog/2014/01/21/ios-performance-tips-and-tricksks</id>
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks">http://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks</a></p></blockquote>

<p>app拥有良好的性能非常重要，这是保证良好用户体验的基石。这篇文章是基于原文，我自己的备忘记录。<!--more--></p>

<hr />

<h2>1.ARC</h2>

<p>新项目现在一般都是基于ARC了，就算使用ARC，很多情况下，还是会有内存泄露的情况存在，所以使用instrument就很必要了。</p>

<p><strong>如何使用instrument：<a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode">http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode</a></strong></p>

<hr />

<h2>2.Reuse</h2>

<h4>1)reuseidentifier</h4>

<ul>
<li>UITableViewCell</li>
<li>UICollectionViewCell</li>
<li>UITableViewHeaderFooterViews</li>
</ul>


<h4>2)Resue &amp;&amp; Lazy load</h4>

<p>学习UITableView的方式，不要一次性创建所有的subView,你只在需要的时候创建subView,并把它添加到reuse Queue;这可以避免大量的消耗。想啊次使用的时候，你只需要reuse即可。</p>

<h4>3)reuse Expensive object</h4>

<p>类似与NSDateFormatter, NSCalendar，这些object的初始化，设置效率比较低，代价比较大。针对这种情况，应该考虑重用。</p>

<p><strong>应对的做法有2种：</strong></p>

<ul>
<li>添加为class的变量，进行reuse</li>
<li>创建一个static variable</li>
</ul>


<p>对于第二种情况，你应该写一个类似与singleton的方法，来获取这个object</p>

<p>```
&ndash;(NSDateFormatter *)fotmatter
{</p>

<pre><code>static NSDateFormatter *formatter;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    _formatter = [[NSDateFormatter alloc] init];
    _formatter.dateFormat = @"EEE MMM dd HH:mm:ss Z yyyy";//twitter date format
});

return formatter;
</code></pre>

<p>}
```</p>

<hr />

<h2>3.set <code>opaque</code> to YES</h2>

<p>default</p>

<hr />

<h2>4.Avoid fat XIBs</h2>

<p>因为在XIB初始化的时候，会直接加载所有内容到内存中，增加大量的开销。因此，尽量把XIB拆分开，只在需要的时候在初始化并进行加载，这样就可以避免一次性加载国语复杂的xib所导致的内存和cpu过量消耗；</p>

<p>当然，现在很多项目使用stroyboard在一定程度上已经缓解了这个问题。</p>

<hr />

<h2>5.DO NOT block Main Thread</h2>

<ul>
<li>GCD</li>
<li>[NSURLConnection sendAsynchronousRequest: completionHandler:]</li>
</ul>


<hr />

<h2>6.<code>Size image</code> to imageVew&rsquo;s size</h2>

<p>事实上，将一个image放入到imageview中，并进行sizeToFit是有很大开销的,而且这部分开销可以避免；
当我们获取到image后，最好先进行resize,然后再放入到合适的imageView中；</p>

<hr />

<h2>7. Choose right data format and structure</h2>

<h4>1)choose <code>correct collection</code></h4>

<ul>
<li>NSArray：<strong>ordered</strong> list of values, <strong>Quick lookup</strong> by <strong>index</strong>, <strong>Slow lookup</strong> by <strong>value</strong>；<strong>Slow</strong> to insert&amp;delete</li>
<li>NSDictionary：key-value pairs, <strong>Quick lookup</strong> by <strong>key</strong></li>
<li>NSSet：unordered list of values, <strong>Quick lookup</strong>by <strong>value</strong>, <strong>Quick</strong> insert&amp;delete</li>
</ul>


<h4>2)choose <code>right data format</code></h4>

<ul>
<li>JSON &ndash; faster to parse, smaller than XML</li>
<li>XML &ndash; soap advantage</li>
</ul>


<h4>3)choose <code>corrent data storage option</code></h4>

<ul>
<li>NSUserDefaults    &ndash;   small data</li>
<li>XML,JSON,Plist    &ndash;   expensive operation to store and parse</li>
<li>NSCoding (archive)&ndash;   expensive as above</li>
<li>sqlite            &ndash;   easy to use</li>
<li>Core Data         &ndash;   like above</li>
</ul>


<hr />

<h2>8.enable GZIP compression</h2>

<hr />

<h2>9.cache</h2>

<p>对于不会变化，并且经常使用到的object进行cache; 对于http cache, 基本的第三方库都已经实现了cache; 对于一般的object，可以使用NSCache:<a href="http://nshipster.com/nscache/">http://nshipster.com/nscache/</a></p>

<hr />

<h2>10. Drawing performance</h2>

<p>考虑不同的绘图机制的性能</p>

<ul>
<li>UIKit</li>
<li>Core Animation</li>
<li>Core Graphics(相对于其他而言，更加高效)</li>
</ul>


<p>//绘制 Shadow Path</p>

<p><code>
//CoreAnimation - 这种方式代价高昂
UIView *view= [[UIView alloc] init];
view.layer.shadowOffst = CGSizeMake(-1.0, 1.0);
view.layer.shadowRadius = 5.0;
view.layer.shadowOpacity = 0.6;
</code></p>

<p><code>
//effective way
view.layer.shadowPath = [[UIBezierPath bezierPathWithRect: view.bounds] CGPath];
</code></p>

<hr />

<h2>11.处理Memory Warnings</h2>

<p>常见有3中方式接收到memory warning</p>

<ol>
<li>applicationDidReceiveMemoryWarning: appDelegate</li>
<li>didReceiveMemoryWarning：           UIViewController</li>
<li>UIApplicationDidReceiveMemoryWarningNotification：notificationCenter</li>
</ol>


<hr />

<h2>12.Avoid Re-Processing Data</h2>

<p>这主要是数据出库的逻辑需要规划好</p>

<hr />

<h2>13. background image</h2>

<ul>
<li>full size image &ndash; [UIImage imageNamed:@&ldquo;test.png&rdquo;];</li>
<li>pattern image &ndash; [UIColor colorWithPatternImage:[UIImage imageNamed:@&ldquo;test.png&rdquo;]];</li>
</ul>


<hr />

<h2>14.reduce your web footprint</h2>

<p>尽量减少javascript的使用</p>

<hr />

<h2>15.Optimize tableview</h2>

<ul>
<li>reuse cell</li>
<li>set subview opaque</li>
<li>avoid gradients, image scale, offscreen drawing</li>
<li>cache height if height is variable</li>
<li>use asynchronously method for cell' contents</li>
<li>use shadowPath to set shadow</li>
<li>reduce te number of subViews</li>
<li>do as little work possible in <code>cellForRowAtIndexPath:</code></li>
<li>use the appropriate data structure</li>
<li>use <code>rowHeight</code>, <code>sectionFooterHeight</code>,<code>sectionHeaderHeight</code> to set constant height instead of delegte(效率上能理解，设计上我自己暂时不是很理解这条)</li>
</ul>


<hr />

<h2>16.speed up Launch time</h2>

<p>注1：异步获取数据，延迟加载，避免臃肿的xib</p>

<p>注2：测试Launch time最有效的方式是，断开Xcode,单独运行你的app</p>

<hr />

<h2>17.image load</h2>

<ul>
<li>imageNamed:               &ndash;   首先从system cache里面查找该image，如果没有找到，再从文件加载image</li>
<li>imageWithContentsOfFile:  &ndash;   直接从文件加载image,不检查system cache</li>
</ul>


<p>注意：对于会多次使用到的image，选择imageNamed：更加合适，因为system cache会进行cache; 而对于单次使用的image，直接从文件加载的imageWithContentsOfFile:更加合适</p>

<hr />

<p>上面的知识点只是针对我个人做备忘，每一个人对此的理解不一样，因此建议看看原文。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中实现设备摇动检测]]></title>
    <link href="http://traximus.github.io/blog/2014/01/20/ioszhong-shi-xian-she-bei-yao-dong-jian-ce/"/>
    <updated>2014-01-20T15:01:09+08:00</updated>
    <id>http://traximus.github.io/blog/2014/01/20/ioszhong-shi-xian-she-bei-yao-dong-jian-ce</id>
    <content type="html"><![CDATA[<p>要检测iOS设备的摇动事件，网上有一些资料。我自己测试过的是下面这2种方式(其实算作一种，只是第二种方式可以在vc里面直接控制是否响应shake事件)<!--more--></p>

<ol>
<li>UIWndow</li>
<li>UIViewController(继承自UIResponder)</li>
</ol>


<hr />

<h3>1.UIWindow</h3>

<p>```
&ndash;(void) motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event
{</p>

<pre><code>//开始
</code></pre>

<p>}</p>

<p>&ndash;(void) motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event
{</p>

<pre><code>if (motion == UIEventSubtypeMotionShake)
{
    //触发结束
    //
    //这里可以促发系统震动，或者发送一个通知，进行相应的处理
    //
    //例子： 添加系统震动
    //  AudioToolBox.framework
    //  #import&lt;AudioToolbox/AudioToolbox.h&gt;
    //  AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);
}
</code></pre>

<p>}</p>

<p>&ndash;(void) motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event
{</p>

<pre><code>//取消
</code></pre>

<p>}
```</p>

<h3>2.UIViewController</h3>

<p>```</p>

<h1>pragma mark &ndash;</h1>

<h1>pragma mark &ndash; viewController methods</h1>

<p>&ndash;(BOOL) canBecomeFirstResponder
{</p>

<pre><code>//这里设定一个变量，来控制是否支持shake事件
return self.shakeDetectionOn;
</code></pre>

<p>}</p>

<p>&ndash;(void) viewDidAppear:(BOOL)animated
{</p>

<pre><code>[super viewDidAppear:animated];

if ([self canBecomeFirstResponder])
{
    //下面这行代码，也可以写到viewDidLoad或者applicationDidFinishLaunch中
    [[UIApplication sharedApplication] setApplicationSupportShakeToEdit:YES];

    [self becomFirstResponder];
}
else
{
    NSLog(@"NOT supported");
}
</code></pre>

<p>}</p>

<h1>pragma mark &ndash;</h1>

<h1>pragma mark &ndash; UIResponder support motion</h1>

<p>&ndash;(void) motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event
{</p>

<pre><code>NSLog(@"======== shake begins ==========");
</code></pre>

<p>}</p>

<p>&ndash;(void) motionCancelled:(UIEventSybtype)motion withEvent:(UIEvent *)event
{</p>

<pre><code>NSLog(@"======== shake cancelled ==========");
</code></pre>

<p>}</p>

<p>&ndash;(void) motionEnd：（UIEventSubtype)motion withEvent:(UIEvent *)event
{</p>

<pre><code>if (motion == UIEventSubtypeMotionShake)
{
    NSLog(@"======== shake ended ========");
    //这里可以添加震动反馈，或者发送notification
}
</code></pre>

<p>}
```</p>

<p>======</p>

<h4>说实话，在实际应用中，很少有合适的场景会用到这个事件；</h4>

<p>而且上面的方式检测shake事件，我自己测试的时候，发现响应有一点延迟，肯定可以再改进；
找机会再慢慢研究一下。</p>
]]></content>
  </entry>
  
</feed>
